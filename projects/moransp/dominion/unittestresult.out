-----------------------------------
TESTING shuffle() 1000 iterations:

Found 137 failures out of 38961 comparisons
File 'dominion.c'
Lines executed:22.16% of 555
Branches executed:20.14% of 417
Taken at least once:17.27% of 417
Calls executed:10.87% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:10
        -:    0:Programs:10
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191498 returned 100% blocks executed 100%
   191498:    8:int compare(const void* a, const void* b) {
   191498:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175002
    16496:   10:    return 1;
   175002:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42019 (fallthrough)
branch  1 taken 132983
    42019:   12:    return -1;
   132983:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2137 returned 100% blocks executed 89%
     2137:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2137:   44:  SelectStream(1);
call    0 returned 2137
     2137:   45:  PutSeed((long)randomSeed);
call    0 returned 2137
        -:   46:  
        -:   47:  //check number of players
     2137:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2137 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2137
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2137:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23507:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21370
branch  1 taken 2137 (fallthrough)
        -:   58:    {
   235070:   59:      for (j = 0; j < 10; j++)
branch  0 taken 213700
branch  1 taken 21370 (fallthrough)
        -:   60:        {
   213700:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 192330 (fallthrough)
branch  1 taken 21370
branch  2 taken 0 (fallthrough)
branch  3 taken 192330
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2137:   73:  if (numPlayers == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2137:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2137:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2137:   87:  if (numPlayers == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2137:   95:      state->supplyCount[estate] = 12;
     2137:   96:      state->supplyCount[duchy] = 12;
     2137:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2137:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2137:  102:  state->supplyCount[silver] = 40;
     2137:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    44877:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 42740
branch  1 taken 2137 (fallthrough)
        -:  107:    {
   352605:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 331235
branch  1 taken 21370 (fallthrough)
        -:  109:	{
   331235:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21370 (fallthrough)
branch  1 taken 309865
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21370:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20371 (fallthrough)
branch  1 taken 999
branch  2 taken 2137 (fallthrough)
branch  3 taken 18234
        -:  114:		{
     6272:  115:		  if (numPlayers == 2){ 
branch  0 taken 0 (fallthrough)
branch  1 taken 3136
    #####:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3136:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18234:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21370:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   309865:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10685:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8548
branch  1 taken 2137 (fallthrough)
        -:  139:    {
     8548:  140:      state->deckCount[i] = 0;
    34192:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25644
branch  1 taken 8548 (fallthrough)
        -:  142:	{
    25644:  143:	  state->deck[i][j] = estate;
    25644:  144:	  state->deckCount[i]++;
        -:  145:	}
    68384:  146:      for (j = 3; j < 10; j++)
branch  0 taken 59836
branch  1 taken 8548 (fallthrough)
        -:  147:	{
    59836:  148:	  state->deck[i][j] = copper;
    59836:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10685:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8548
branch  1 taken 2137 (fallthrough)
        -:  155:    {
     8548:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8548
branch  1 taken 0 (fallthrough)
branch  2 taken 8548
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10685:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8548
branch  1 taken 2137 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8548:  166:      state->handCount[i] = 0;
     8548:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    59836:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 57699
branch  1 taken 2137 (fallthrough)
        -:  177:    {
    57699:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2137:  182:  state->outpostPlayed = 0;
     2137:  183:  state->phase = 0;
     2137:  184:  state->numActions = 1;
     2137:  185:  state->numBuys = 1;
     2137:  186:  state->playedCardCount = 0;
     2137:  187:  state->whoseTurn = 0;
     2137:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12822:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10685
branch  1 taken 2137 (fallthrough)
    10685:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10685
        -:  194:  }
        -:  195:
     2137:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2137
        -:  197:
     2137:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16298 returned 100% blocks executed 100%
    16298:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16298:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16298:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13155
     3143:  210:    return -1;
    13155:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13155
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   147672:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121362
branch  1 taken 13155 (fallthrough)
   121362:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121362
   121362:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121362:  217:    newDeckPos++;
   394700:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 273338
branch  1 taken 121362 (fallthrough)
   273338:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121362:  221:    state->deckCount[player]--;
        -:  222:  }
   134517:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121362
branch  1 taken 13155 (fallthrough)
   121362:  224:    state->deck[player][i] = newDeck[i];
   121362:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13155:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 9 returned 100% blocks executed 100%
        9:  346:int whoseTurn(struct gameState *state) {
        9:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15761 returned 100% blocks executed 100%
    15761:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15761:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13884
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13884:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13884:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13884:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13884:  576:    state->deckCount[player]--;
    13884:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14495:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 0 returned 0% blocks executed 0%
    #####:  583:int getCost(int cardNumber)
        -:  584:{
    #####:  585:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
    #####:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
    #####:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
    #####: 1319:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
    #####: 1324:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
    #####: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
    #####: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
    #####: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2137 returned 100% blocks executed 82%
     2137: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2137: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12822: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10685
branch  1 taken 2137 (fallthrough)
        -: 1350:    {
    10685: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8383 (fallthrough)
branch  1 taken 2302
        -: 1352:	{
     8383: 1353:	  state->coins += 1;
        -: 1354:	}
     2302: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2302
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2302: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2302
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2137: 1366:  state->coins += bonus;
        -: 1367:
     2137: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING buyCard()------
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:8
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:7
PASS - Expected value:7, Actual:7
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:2
PASS - Expected value:2, Actual:2
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:1
PASS - Expected value:1, Actual:1
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
Failures found:0

buyCard() All Tests Passed
File 'dominion.c'
Lines executed:29.01% of 555
Branches executed:29.74% of 417
Taken at least once:22.06% of 417
Calls executed:16.30% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:11
        -:    0:Programs:11
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191798 returned 100% blocks executed 100%
   191798:    8:int compare(const void* a, const void* b) {
   191798:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175302
    16496:   10:    return 1;
   175302:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42099 (fallthrough)
branch  1 taken 133203
    42099:   12:    return -1;
   133203:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2147 returned 100% blocks executed 94%
     2147:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2147:   44:  SelectStream(1);
call    0 returned 2147
     2147:   45:  PutSeed((long)randomSeed);
call    0 returned 2147
        -:   46:  
        -:   47:  //check number of players
     2147:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2147 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2147
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2147:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23617:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21470
branch  1 taken 2147 (fallthrough)
        -:   58:    {
   236170:   59:      for (j = 0; j < 10; j++)
branch  0 taken 214700
branch  1 taken 21470 (fallthrough)
        -:   60:        {
   214700:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193230 (fallthrough)
branch  1 taken 21470
branch  2 taken 0 (fallthrough)
branch  3 taken 193230
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2147:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2137
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2137:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2137:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2147:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2137
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2137:   95:      state->supplyCount[estate] = 12;
     2137:   96:      state->supplyCount[duchy] = 12;
     2137:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2147:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2147:  102:  state->supplyCount[silver] = 40;
     2147:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45087:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 42940
branch  1 taken 2147 (fallthrough)
        -:  107:    {
   354255:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 332785
branch  1 taken 21470 (fallthrough)
        -:  109:	{
   332785:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21470 (fallthrough)
branch  1 taken 311315
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21470:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20471 (fallthrough)
branch  1 taken 999
branch  2 taken 2147 (fallthrough)
branch  3 taken 18324
        -:  114:		{
     6292:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3136
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3136:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18324:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21470:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311315:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10715:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  139:    {
     8568:  140:      state->deckCount[i] = 0;
    34272:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25704
branch  1 taken 8568 (fallthrough)
        -:  142:	{
    25704:  143:	  state->deck[i][j] = estate;
    25704:  144:	  state->deckCount[i]++;
        -:  145:	}
    68544:  146:      for (j = 3; j < 10; j++)
branch  0 taken 59976
branch  1 taken 8568 (fallthrough)
        -:  147:	{
    59976:  148:	  state->deck[i][j] = copper;
    59976:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10715:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  155:    {
     8568:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8568
branch  1 taken 0 (fallthrough)
branch  2 taken 8568
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10715:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8568:  166:      state->handCount[i] = 0;
     8568:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60116:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 57969
branch  1 taken 2147 (fallthrough)
        -:  177:    {
    57969:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2147:  182:  state->outpostPlayed = 0;
     2147:  183:  state->phase = 0;
     2147:  184:  state->numActions = 1;
     2147:  185:  state->numBuys = 1;
     2147:  186:  state->playedCardCount = 0;
     2147:  187:  state->whoseTurn = 0;
     2147:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12882:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10735
branch  1 taken 2147 (fallthrough)
    10735:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10735
        -:  194:  }
        -:  195:
     2147:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2147
        -:  197:
     2147:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16318 returned 100% blocks executed 100%
    16318:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16318:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16318:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13175
     3143:  210:    return -1;
    13175:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13175
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   147912:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121562
branch  1 taken 13175 (fallthrough)
   121562:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121562
   121562:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121562:  217:    newDeckPos++;
   395400:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 273838
branch  1 taken 121562 (fallthrough)
   273838:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121562:  221:    state->deckCount[player]--;
        -:  222:  }
   134737:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121562
branch  1 taken 13175 (fallthrough)
   121562:  224:    state->deck[player][i] = newDeck[i];
   121562:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13175:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 9 returned 100% blocks executed 100%
        9:  346:int whoseTurn(struct gameState *state) {
        9:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15811 returned 100% blocks executed 100%
    15811:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15811:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13934
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13934:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13934:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13934:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13934:  576:    state->deckCount[player]--;
    13934:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14545:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 16 returned 100% blocks executed 40%
       16:  583:int getCost(int cardNumber)
        -:  584:{
       16:  585:  switch( cardNumber ) 
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 1
branch  8 taken 0
branch  9 taken 0
branch 10 taken 2
branch 11 taken 1
branch 12 taken 0
branch 13 taken 2
branch 14 taken 2
branch 15 taken 0
branch 16 taken 0
branch 17 taken 1
branch 18 taken 0
branch 19 taken 1
branch 20 taken 0
branch 21 taken 2
branch 22 taken 2
branch 23 taken 0
branch 24 taken 0
branch 25 taken 2
branch 26 taken 0
branch 27 taken 0
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
        2:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
        2:  614:      return 4;
        -:  615:    case village:
        2:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
        2:  630:      return 4;
        -:  631:    case embargo: 
        2:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
        2:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2147 returned 100% blocks executed 82%
     2147: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2147: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12882: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10735
branch  1 taken 2147 (fallthrough)
        -: 1350:    {
    10735: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8423 (fallthrough)
branch  1 taken 2312
        -: 1352:	{
     8423: 1353:	  state->coins += 1;
        -: 1354:	}
     2312: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2312
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2312: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2312
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2147: 1366:  state->coins += bonus;
        -: 1367:
     2147: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:
PASS - Expected value:0, Actual:0
PASS - Expected value:2, Actual:2
PASS - Expected value:5, Actual:5
PASS - Expected value:8, Actual:8
PASS - Expected value:0, Actual:0
PASS - Expected value:3, Actual:3
PASS - Expected value:6, Actual:6
PASS - Expected value:6, Actual:6
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:3, Actual:3
PASS - Expected value:4, Actual:4
PASS - Expected value:3, Actual:3
PASS - Expected value:5, Actual:5
PASS - Expected value:3, Actual:3
PASS - Expected value:5, Actual:5
PASS - Expected value:3, Actual:3
PASS - Expected value:4, Actual:4
PASS - Expected value:2, Actual:2
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:0, Actual:0
PASS - Expected value:-1, Actual:-1
PASS - Expected value:-1, Actual:-1
Values checked report(s) 0 errors
All tests passed
File 'dominion.c'
Lines executed:32.25% of 555
Branches executed:29.74% of 417
Taken at least once:26.38% of 417
Calls executed:16.30% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:12
        -:    0:Programs:12
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191798 returned 100% blocks executed 100%
   191798:    8:int compare(const void* a, const void* b) {
   191798:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175302
    16496:   10:    return 1;
   175302:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42099 (fallthrough)
branch  1 taken 133203
    42099:   12:    return -1;
   133203:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2147 returned 100% blocks executed 94%
     2147:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2147:   44:  SelectStream(1);
call    0 returned 2147
     2147:   45:  PutSeed((long)randomSeed);
call    0 returned 2147
        -:   46:  
        -:   47:  //check number of players
     2147:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2147 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2147
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2147:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23617:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21470
branch  1 taken 2147 (fallthrough)
        -:   58:    {
   236170:   59:      for (j = 0; j < 10; j++)
branch  0 taken 214700
branch  1 taken 21470 (fallthrough)
        -:   60:        {
   214700:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193230 (fallthrough)
branch  1 taken 21470
branch  2 taken 0 (fallthrough)
branch  3 taken 193230
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2147:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2137
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2137:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2137
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2137:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2147:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2137
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2137:   95:      state->supplyCount[estate] = 12;
     2137:   96:      state->supplyCount[duchy] = 12;
     2137:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2147:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2147:  102:  state->supplyCount[silver] = 40;
     2147:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45087:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 42940
branch  1 taken 2147 (fallthrough)
        -:  107:    {
   354255:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 332785
branch  1 taken 21470 (fallthrough)
        -:  109:	{
   332785:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21470 (fallthrough)
branch  1 taken 311315
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21470:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20471 (fallthrough)
branch  1 taken 999
branch  2 taken 2147 (fallthrough)
branch  3 taken 18324
        -:  114:		{
     6292:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3136
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3136:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18324:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21470:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311315:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10715:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  139:    {
     8568:  140:      state->deckCount[i] = 0;
    34272:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25704
branch  1 taken 8568 (fallthrough)
        -:  142:	{
    25704:  143:	  state->deck[i][j] = estate;
    25704:  144:	  state->deckCount[i]++;
        -:  145:	}
    68544:  146:      for (j = 3; j < 10; j++)
branch  0 taken 59976
branch  1 taken 8568 (fallthrough)
        -:  147:	{
    59976:  148:	  state->deck[i][j] = copper;
    59976:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10715:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  155:    {
     8568:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8568
branch  1 taken 0 (fallthrough)
branch  2 taken 8568
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10715:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8568
branch  1 taken 2147 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8568:  166:      state->handCount[i] = 0;
     8568:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60116:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 57969
branch  1 taken 2147 (fallthrough)
        -:  177:    {
    57969:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2147:  182:  state->outpostPlayed = 0;
     2147:  183:  state->phase = 0;
     2147:  184:  state->numActions = 1;
     2147:  185:  state->numBuys = 1;
     2147:  186:  state->playedCardCount = 0;
     2147:  187:  state->whoseTurn = 0;
     2147:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12882:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10735
branch  1 taken 2147 (fallthrough)
    10735:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10735
        -:  194:  }
        -:  195:
     2147:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2147
        -:  197:
     2147:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16318 returned 100% blocks executed 100%
    16318:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16318:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16318:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13175
     3143:  210:    return -1;
    13175:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13175
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   147912:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121562
branch  1 taken 13175 (fallthrough)
   121562:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121562
   121562:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121562:  217:    newDeckPos++;
   395400:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 273838
branch  1 taken 121562 (fallthrough)
   273838:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121562:  221:    state->deckCount[player]--;
        -:  222:  }
   134737:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121562
branch  1 taken 13175 (fallthrough)
   121562:  224:    state->deck[player][i] = newDeck[i];
   121562:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13175:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 9 returned 100% blocks executed 100%
        9:  346:int whoseTurn(struct gameState *state) {
        9:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15811 returned 100% blocks executed 100%
    15811:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15811:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13934
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13934:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13934:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13934:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13934:  576:    state->deckCount[player]--;
    13934:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14545:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2147 returned 100% blocks executed 82%
     2147: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2147: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12882: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10735
branch  1 taken 2147 (fallthrough)
        -: 1350:    {
    10735: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8423 (fallthrough)
branch  1 taken 2312
        -: 1352:	{
     8423: 1353:	  state->coins += 1;
        -: 1354:	}
     2312: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2312
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2312: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2312
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2147: 1366:  state->coins += bonus;
        -: 1367:
     2147: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING endTurn()------
********************************
it is currently player 0's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:1, Actual:1
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
********************************
it is currently player 1's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:2, Actual:2
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		FAIL - Expected value: 3, Actual: 4
********************************
it is currently player 2's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:3, Actual:3
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
********************************
it is currently player 3's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:0, Actual:0
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
Failures found:1
File 'dominion.c'
Lines executed:35.86% of 555
Branches executed:31.18% of 417
Taken at least once:27.82% of 417
Calls executed:19.57% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:13
        -:    0:Programs:13
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191858 returned 100% blocks executed 100%
   191858:    8:int compare(const void* a, const void* b) {
   191858:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175362
    16496:   10:    return 1;
   175362:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42115 (fallthrough)
branch  1 taken 133247
    42115:   12:    return -1;
   133247:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2148 returned 100% blocks executed 94%
     2148:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2148:   44:  SelectStream(1);
call    0 returned 2148
     2148:   45:  PutSeed((long)randomSeed);
call    0 returned 2148
        -:   46:  
        -:   47:  //check number of players
     2148:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2148 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2148
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2148:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23628:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21480
branch  1 taken 2148 (fallthrough)
        -:   58:    {
   236280:   59:      for (j = 0; j < 10; j++)
branch  0 taken 214800
branch  1 taken 21480 (fallthrough)
        -:   60:        {
   214800:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193320 (fallthrough)
branch  1 taken 21480
branch  2 taken 0 (fallthrough)
branch  3 taken 193320
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2148:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2138
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2138:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2138
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2138:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2148:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2138
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2138:   95:      state->supplyCount[estate] = 12;
     2138:   96:      state->supplyCount[duchy] = 12;
     2138:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2148:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2148:  102:  state->supplyCount[silver] = 40;
     2148:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45108:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 42960
branch  1 taken 2148 (fallthrough)
        -:  107:    {
   354420:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 332940
branch  1 taken 21480 (fallthrough)
        -:  109:	{
   332940:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21480 (fallthrough)
branch  1 taken 311460
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21480:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20481 (fallthrough)
branch  1 taken 999
branch  2 taken 2148 (fallthrough)
branch  3 taken 18333
        -:  114:		{
     6294:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3137
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3137:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18333:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21480:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311460:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10720:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8572
branch  1 taken 2148 (fallthrough)
        -:  139:    {
     8572:  140:      state->deckCount[i] = 0;
    34288:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25716
branch  1 taken 8572 (fallthrough)
        -:  142:	{
    25716:  143:	  state->deck[i][j] = estate;
    25716:  144:	  state->deckCount[i]++;
        -:  145:	}
    68576:  146:      for (j = 3; j < 10; j++)
branch  0 taken 60004
branch  1 taken 8572 (fallthrough)
        -:  147:	{
    60004:  148:	  state->deck[i][j] = copper;
    60004:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10720:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8572
branch  1 taken 2148 (fallthrough)
        -:  155:    {
     8572:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8572
branch  1 taken 0 (fallthrough)
branch  2 taken 8572
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10720:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8572
branch  1 taken 2148 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8572:  166:      state->handCount[i] = 0;
     8572:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60144:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 57996
branch  1 taken 2148 (fallthrough)
        -:  177:    {
    57996:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2148:  182:  state->outpostPlayed = 0;
     2148:  183:  state->phase = 0;
     2148:  184:  state->numActions = 1;
     2148:  185:  state->numBuys = 1;
     2148:  186:  state->playedCardCount = 0;
     2148:  187:  state->whoseTurn = 0;
     2148:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12888:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10740
branch  1 taken 2148 (fallthrough)
    10740:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10740
        -:  194:  }
        -:  195:
     2148:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2148
        -:  197:
     2148:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16322 returned 100% blocks executed 100%
    16322:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16322:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16322:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13179
     3143:  210:    return -1;
    13179:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13179
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   147960:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121602
branch  1 taken 13179 (fallthrough)
   121602:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121602
   121602:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121602:  217:    newDeckPos++;
   395539:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 273937
branch  1 taken 121602 (fallthrough)
   273937:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121602:  221:    state->deckCount[player]--;
        -:  222:  }
   134781:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121602
branch  1 taken 13179 (fallthrough)
   121602:  224:    state->deck[player][i] = newDeck[i];
   121602:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13179:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 13 returned 100% blocks executed 100%
       13:  346:int whoseTurn(struct gameState *state) {
       13:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15836 returned 100% blocks executed 100%
    15836:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15836:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13959
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13959:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13959:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13959:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13959:  576:    state->deckCount[player]--;
    13959:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14570:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2152 returned 100% blocks executed 82%
     2152: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2152: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12912: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10760
branch  1 taken 2152 (fallthrough)
        -: 1350:    {
    10760: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8440 (fallthrough)
branch  1 taken 2320
        -: 1352:	{
     8440: 1353:	  state->coins += 1;
        -: 1354:	}
     2320: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2320
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2320: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2320
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2152: 1366:  state->coins += bonus;
        -: 1367:
     2152: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:36.58% of 555
Branches executed:31.65% of 417
Taken at least once:28.30% of 417
Calls executed:20.65% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:14
        -:    0:Programs:14
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191918 returned 100% blocks executed 100%
   191918:    8:int compare(const void* a, const void* b) {
   191918:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175422
    16496:   10:    return 1;
   175422:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42131 (fallthrough)
branch  1 taken 133291
    42131:   12:    return -1;
   133291:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2149 returned 100% blocks executed 94%
     2149:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2149:   44:  SelectStream(1);
call    0 returned 2149
     2149:   45:  PutSeed((long)randomSeed);
call    0 returned 2149
        -:   46:  
        -:   47:  //check number of players
     2149:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2149 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2149
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2149:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23639:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21490
branch  1 taken 2149 (fallthrough)
        -:   58:    {
   236390:   59:      for (j = 0; j < 10; j++)
branch  0 taken 214900
branch  1 taken 21490 (fallthrough)
        -:   60:        {
   214900:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193410 (fallthrough)
branch  1 taken 21490
branch  2 taken 0 (fallthrough)
branch  3 taken 193410
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2149:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2139
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2139:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2139
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2139:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2149:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2139
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2139:   95:      state->supplyCount[estate] = 12;
     2139:   96:      state->supplyCount[duchy] = 12;
     2139:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2149:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2149:  102:  state->supplyCount[silver] = 40;
     2149:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45129:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 42980
branch  1 taken 2149 (fallthrough)
        -:  107:    {
   354585:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 333095
branch  1 taken 21490 (fallthrough)
        -:  109:	{
   333095:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21490 (fallthrough)
branch  1 taken 311605
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21490:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20491 (fallthrough)
branch  1 taken 999
branch  2 taken 2149 (fallthrough)
branch  3 taken 18342
        -:  114:		{
     6296:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3138
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3138:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18342:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21490:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311605:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10725:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8576
branch  1 taken 2149 (fallthrough)
        -:  139:    {
     8576:  140:      state->deckCount[i] = 0;
    34304:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25728
branch  1 taken 8576 (fallthrough)
        -:  142:	{
    25728:  143:	  state->deck[i][j] = estate;
    25728:  144:	  state->deckCount[i]++;
        -:  145:	}
    68608:  146:      for (j = 3; j < 10; j++)
branch  0 taken 60032
branch  1 taken 8576 (fallthrough)
        -:  147:	{
    60032:  148:	  state->deck[i][j] = copper;
    60032:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10725:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8576
branch  1 taken 2149 (fallthrough)
        -:  155:    {
     8576:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8576
branch  1 taken 0 (fallthrough)
branch  2 taken 8576
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10725:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8576
branch  1 taken 2149 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8576:  166:      state->handCount[i] = 0;
     8576:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60172:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 58023
branch  1 taken 2149 (fallthrough)
        -:  177:    {
    58023:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2149:  182:  state->outpostPlayed = 0;
     2149:  183:  state->phase = 0;
     2149:  184:  state->numActions = 1;
     2149:  185:  state->numBuys = 1;
     2149:  186:  state->playedCardCount = 0;
     2149:  187:  state->whoseTurn = 0;
     2149:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12894:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10745
branch  1 taken 2149 (fallthrough)
    10745:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10745
        -:  194:  }
        -:  195:
     2149:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2149
        -:  197:
     2149:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16326 returned 100% blocks executed 100%
    16326:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16326:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16326:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13183
     3143:  210:    return -1;
    13183:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13183
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   148008:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121642
branch  1 taken 13183 (fallthrough)
   121642:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121642
   121642:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121642:  217:    newDeckPos++;
   395678:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 274036
branch  1 taken 121642 (fallthrough)
   274036:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121642:  221:    state->deckCount[player]--;
        -:  222:  }
   134825:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121642
branch  1 taken 13183 (fallthrough)
   121642:  224:    state->deck[player][i] = newDeck[i];
   121642:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13183:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 13 returned 100% blocks executed 100%
       13:  346:int whoseTurn(struct gameState *state) {
       13:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15844 returned 100% blocks executed 100%
    15844:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15844:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13967
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13967:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13967:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13967:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13967:  576:    state->deckCount[player]--;
    13967:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14578:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 1 returned 100% blocks executed 100%
        1:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
        4:  652:  for (i = 0; i < 3; i++)
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        -:  653:	{
        3:  654:	  drawCard(currentPlayer, state);
call    0 returned 3
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        1:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2153 returned 100% blocks executed 82%
     2153: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2153: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12918: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10765
branch  1 taken 2153 (fallthrough)
        -: 1350:    {
    10765: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8444 (fallthrough)
branch  1 taken 2321
        -: 1352:	{
     8444: 1353:	  state->coins += 1;
        -: 1354:	}
     2321: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2321
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2321: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2321
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2153: 1366:  state->coins += bonus;
        -: 1367:
     2153: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:36.58% of 555
Branches executed:31.65% of 417
Taken at least once:28.30% of 417
Calls executed:20.65% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:15
        -:    0:Programs:15
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 191978 returned 100% blocks executed 100%
   191978:    8:int compare(const void* a, const void* b) {
   191978:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175482
    16496:   10:    return 1;
   175482:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42147 (fallthrough)
branch  1 taken 133335
    42147:   12:    return -1;
   133335:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2150 returned 100% blocks executed 94%
     2150:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2150:   44:  SelectStream(1);
call    0 returned 2150
     2150:   45:  PutSeed((long)randomSeed);
call    0 returned 2150
        -:   46:  
        -:   47:  //check number of players
     2150:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2150 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2150
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2150:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23650:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21500
branch  1 taken 2150 (fallthrough)
        -:   58:    {
   236500:   59:      for (j = 0; j < 10; j++)
branch  0 taken 215000
branch  1 taken 21500 (fallthrough)
        -:   60:        {
   215000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193500 (fallthrough)
branch  1 taken 21500
branch  2 taken 0 (fallthrough)
branch  3 taken 193500
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2150:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2140
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2140:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2140
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2140:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2150:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2140
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2140:   95:      state->supplyCount[estate] = 12;
     2140:   96:      state->supplyCount[duchy] = 12;
     2140:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2150:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2150:  102:  state->supplyCount[silver] = 40;
     2150:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45150:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 43000
branch  1 taken 2150 (fallthrough)
        -:  107:    {
   354750:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 333250
branch  1 taken 21500 (fallthrough)
        -:  109:	{
   333250:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21500 (fallthrough)
branch  1 taken 311750
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21500:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20501 (fallthrough)
branch  1 taken 999
branch  2 taken 2150 (fallthrough)
branch  3 taken 18351
        -:  114:		{
     6298:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3139
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3139:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18351:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21500:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311750:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10730:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8580
branch  1 taken 2150 (fallthrough)
        -:  139:    {
     8580:  140:      state->deckCount[i] = 0;
    34320:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25740
branch  1 taken 8580 (fallthrough)
        -:  142:	{
    25740:  143:	  state->deck[i][j] = estate;
    25740:  144:	  state->deckCount[i]++;
        -:  145:	}
    68640:  146:      for (j = 3; j < 10; j++)
branch  0 taken 60060
branch  1 taken 8580 (fallthrough)
        -:  147:	{
    60060:  148:	  state->deck[i][j] = copper;
    60060:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10730:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8580
branch  1 taken 2150 (fallthrough)
        -:  155:    {
     8580:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8580
branch  1 taken 0 (fallthrough)
branch  2 taken 8580
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10730:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8580
branch  1 taken 2150 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8580:  166:      state->handCount[i] = 0;
     8580:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60200:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 58050
branch  1 taken 2150 (fallthrough)
        -:  177:    {
    58050:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2150:  182:  state->outpostPlayed = 0;
     2150:  183:  state->phase = 0;
     2150:  184:  state->numActions = 1;
     2150:  185:  state->numBuys = 1;
     2150:  186:  state->playedCardCount = 0;
     2150:  187:  state->whoseTurn = 0;
     2150:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12900:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10750
branch  1 taken 2150 (fallthrough)
    10750:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10750
        -:  194:  }
        -:  195:
     2150:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2150
        -:  197:
     2150:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16330 returned 100% blocks executed 100%
    16330:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16330:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16330:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13187
     3143:  210:    return -1;
    13187:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13187
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   148056:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121682
branch  1 taken 13187 (fallthrough)
   121682:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121682
   121682:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121682:  217:    newDeckPos++;
   395817:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 274135
branch  1 taken 121682 (fallthrough)
   274135:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121682:  221:    state->deckCount[player]--;
        -:  222:  }
   134869:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121682
branch  1 taken 13187 (fallthrough)
   121682:  224:    state->deck[player][i] = newDeck[i];
   121682:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13187:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 13 returned 100% blocks executed 100%
       13:  346:int whoseTurn(struct gameState *state) {
       13:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15852 returned 100% blocks executed 100%
    15852:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15852:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13975
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13975:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13975:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13975:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13975:  576:    state->deckCount[player]--;
    13975:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14586:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 2 returned 100% blocks executed 100%
        2:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
        8:  652:  for (i = 0; i < 3; i++)
branch  0 taken 6
branch  1 taken 2 (fallthrough)
        -:  653:	{
        6:  654:	  drawCard(currentPlayer, state);
call    0 returned 6
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        2:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2154 returned 100% blocks executed 82%
     2154: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2154: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12924: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10770
branch  1 taken 2154 (fallthrough)
        -: 1350:    {
    10770: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8448 (fallthrough)
branch  1 taken 2322
        -: 1352:	{
     8448: 1353:	  state->coins += 1;
        -: 1354:	}
     2322: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2322
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2322: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2322
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2154: 1366:  state->coins += bonus;
        -: 1367:
     2154: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:36.58% of 555
Branches executed:31.65% of 417
Taken at least once:28.30% of 417
Calls executed:20.65% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:16
        -:    0:Programs:16
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 192038 returned 100% blocks executed 100%
   192038:    8:int compare(const void* a, const void* b) {
   192038:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175542
    16496:   10:    return 1;
   175542:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42163 (fallthrough)
branch  1 taken 133379
    42163:   12:    return -1;
   133379:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2151 returned 100% blocks executed 94%
     2151:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2151:   44:  SelectStream(1);
call    0 returned 2151
     2151:   45:  PutSeed((long)randomSeed);
call    0 returned 2151
        -:   46:  
        -:   47:  //check number of players
     2151:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2151 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2151
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2151:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23661:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21510
branch  1 taken 2151 (fallthrough)
        -:   58:    {
   236610:   59:      for (j = 0; j < 10; j++)
branch  0 taken 215100
branch  1 taken 21510 (fallthrough)
        -:   60:        {
   215100:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193590 (fallthrough)
branch  1 taken 21510
branch  2 taken 0 (fallthrough)
branch  3 taken 193590
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2151:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2141
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2141:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2141
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2141:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2151:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2141
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2141:   95:      state->supplyCount[estate] = 12;
     2141:   96:      state->supplyCount[duchy] = 12;
     2141:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2151:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2151:  102:  state->supplyCount[silver] = 40;
     2151:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45171:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 43020
branch  1 taken 2151 (fallthrough)
        -:  107:    {
   354915:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 333405
branch  1 taken 21510 (fallthrough)
        -:  109:	{
   333405:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21510 (fallthrough)
branch  1 taken 311895
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21510:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20511 (fallthrough)
branch  1 taken 999
branch  2 taken 2151 (fallthrough)
branch  3 taken 18360
        -:  114:		{
     6300:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3140
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3140:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18360:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21510:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   311895:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10735:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8584
branch  1 taken 2151 (fallthrough)
        -:  139:    {
     8584:  140:      state->deckCount[i] = 0;
    34336:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25752
branch  1 taken 8584 (fallthrough)
        -:  142:	{
    25752:  143:	  state->deck[i][j] = estate;
    25752:  144:	  state->deckCount[i]++;
        -:  145:	}
    68672:  146:      for (j = 3; j < 10; j++)
branch  0 taken 60088
branch  1 taken 8584 (fallthrough)
        -:  147:	{
    60088:  148:	  state->deck[i][j] = copper;
    60088:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10735:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8584
branch  1 taken 2151 (fallthrough)
        -:  155:    {
     8584:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8584
branch  1 taken 0 (fallthrough)
branch  2 taken 8584
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10735:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8584
branch  1 taken 2151 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8584:  166:      state->handCount[i] = 0;
     8584:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60228:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 58077
branch  1 taken 2151 (fallthrough)
        -:  177:    {
    58077:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2151:  182:  state->outpostPlayed = 0;
     2151:  183:  state->phase = 0;
     2151:  184:  state->numActions = 1;
     2151:  185:  state->numBuys = 1;
     2151:  186:  state->playedCardCount = 0;
     2151:  187:  state->whoseTurn = 0;
     2151:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12906:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10755
branch  1 taken 2151 (fallthrough)
    10755:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10755
        -:  194:  }
        -:  195:
     2151:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2151
        -:  197:
     2151:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16334 returned 100% blocks executed 100%
    16334:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16334:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16334:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13191
     3143:  210:    return -1;
    13191:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13191
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   148104:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121722
branch  1 taken 13191 (fallthrough)
   121722:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121722
   121722:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121722:  217:    newDeckPos++;
   395956:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 274234
branch  1 taken 121722 (fallthrough)
   274234:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121722:  221:    state->deckCount[player]--;
        -:  222:  }
   134913:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121722
branch  1 taken 13191 (fallthrough)
   121722:  224:    state->deck[player][i] = newDeck[i];
   121722:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13191:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 13 returned 100% blocks executed 100%
       13:  346:int whoseTurn(struct gameState *state) {
       13:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15860 returned 100% blocks executed 100%
    15860:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15860:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13983
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13983:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13983:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13983:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13983:  576:    state->deckCount[player]--;
    13983:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14594:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 3 returned 100% blocks executed 100%
        3:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
       12:  652:  for (i = 0; i < 3; i++)
branch  0 taken 9
branch  1 taken 3 (fallthrough)
        -:  653:	{
        9:  654:	  drawCard(currentPlayer, state);
call    0 returned 9
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        3:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2155 returned 100% blocks executed 82%
     2155: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2155: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12930: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10775
branch  1 taken 2155 (fallthrough)
        -: 1350:    {
    10775: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8452 (fallthrough)
branch  1 taken 2323
        -: 1352:	{
     8452: 1353:	  state->coins += 1;
        -: 1354:	}
     2323: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2323
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2323: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2323
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2155: 1366:  state->coins += bonus;
        -: 1367:
     2155: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:36.58% of 555
Branches executed:31.65% of 417
Taken at least once:28.30% of 417
Calls executed:20.65% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:17
        -:    0:Programs:17
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 192098 returned 100% blocks executed 100%
   192098:    8:int compare(const void* a, const void* b) {
   192098:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 175602
    16496:   10:    return 1;
   175602:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 42179 (fallthrough)
branch  1 taken 133423
    42179:   12:    return -1;
   133423:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 2152 returned 100% blocks executed 94%
     2152:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     2152:   44:  SelectStream(1);
call    0 returned 2152
     2152:   45:  PutSeed((long)randomSeed);
call    0 returned 2152
        -:   46:  
        -:   47:  //check number of players
     2152:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 2152 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2152
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     2152:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    23672:   57:  for (i = 0; i < 10; i++)
branch  0 taken 21520
branch  1 taken 2152 (fallthrough)
        -:   58:    {
   236720:   59:      for (j = 0; j < 10; j++)
branch  0 taken 215200
branch  1 taken 21520 (fallthrough)
        -:   60:        {
   215200:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 193680 (fallthrough)
branch  1 taken 21520
branch  2 taken 0 (fallthrough)
branch  3 taken 193680
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     2152:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2142
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     2142:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 2142
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     2142:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     2152:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 2142
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     2142:   95:      state->supplyCount[estate] = 12;
     2142:   96:      state->supplyCount[duchy] = 12;
     2142:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     2152:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     2152:  102:  state->supplyCount[silver] = 40;
     2152:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    45192:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 43040
branch  1 taken 2152 (fallthrough)
        -:  107:    {
   355080:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 333560
branch  1 taken 21520 (fallthrough)
        -:  109:	{
   333560:  110:	  if (kingdomCards[j] == i)
branch  0 taken 21520 (fallthrough)
branch  1 taken 312040
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    21520:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 20521 (fallthrough)
branch  1 taken 999
branch  2 taken 2152 (fallthrough)
branch  3 taken 18369
        -:  114:		{
     6302:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 3141
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     3141:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    18369:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    21520:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   312040:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    10740:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8588
branch  1 taken 2152 (fallthrough)
        -:  139:    {
     8588:  140:      state->deckCount[i] = 0;
    34352:  141:      for (j = 0; j < 3; j++)
branch  0 taken 25764
branch  1 taken 8588 (fallthrough)
        -:  142:	{
    25764:  143:	  state->deck[i][j] = estate;
    25764:  144:	  state->deckCount[i]++;
        -:  145:	}
    68704:  146:      for (j = 3; j < 10; j++)
branch  0 taken 60116
branch  1 taken 8588 (fallthrough)
        -:  147:	{
    60116:  148:	  state->deck[i][j] = copper;
    60116:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    10740:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8588
branch  1 taken 2152 (fallthrough)
        -:  155:    {
     8588:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 8588
branch  1 taken 0 (fallthrough)
branch  2 taken 8588
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    10740:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 8588
branch  1 taken 2152 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     8588:  166:      state->handCount[i] = 0;
     8588:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    60256:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 58104
branch  1 taken 2152 (fallthrough)
        -:  177:    {
    58104:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     2152:  182:  state->outpostPlayed = 0;
     2152:  183:  state->phase = 0;
     2152:  184:  state->numActions = 1;
     2152:  185:  state->numBuys = 1;
     2152:  186:  state->playedCardCount = 0;
     2152:  187:  state->whoseTurn = 0;
     2152:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    12912:  192:  for (it = 0; it < 5; it++){
branch  0 taken 10760
branch  1 taken 2152 (fallthrough)
    10760:  193:    drawCard(state->whoseTurn, state);
call    0 returned 10760
        -:  194:  }
        -:  195:
     2152:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 2152
        -:  197:
     2152:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 16338 returned 100% blocks executed 100%
    16338:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    16338:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    16338:  209:  if (state->deckCount[player] < 1)
branch  0 taken 3143 (fallthrough)
branch  1 taken 13195
     3143:  210:    return -1;
    13195:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 13195
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
   148152:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 121762
branch  1 taken 13195 (fallthrough)
   121762:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 121762
   121762:  216:    newDeck[newDeckPos] = state->deck[player][card];
   121762:  217:    newDeckPos++;
   396095:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 274333
branch  1 taken 121762 (fallthrough)
   274333:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
   121762:  221:    state->deckCount[player]--;
        -:  222:  }
   134957:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 121762
branch  1 taken 13195 (fallthrough)
   121762:  224:    state->deck[player][i] = newDeck[i];
   121762:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    13195:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 13 returned 100% blocks executed 100%
       13:  346:int whoseTurn(struct gameState *state) {
       13:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 15868 returned 100% blocks executed 100%
    15868:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    15868:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1877 (fallthrough)
branch  1 taken 13991
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     2794:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 917
branch  1 taken 1877 (fallthrough)
      917:  534:      state->deck[player][i] = state->discard[player][i];
      917:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
     1877:  538:    state->deckCount[player] = state->discardCount[player];
     1877:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1877:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 1877
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1877:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1877:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1877:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1877:  559:    if (deckCounter == 0)
branch  0 taken 1266 (fallthrough)
branch  1 taken 611
     1266:  560:      return -1;
        -:  561:
      611:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      611:  563:    state->deckCount[player]--;
      611:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    13991:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    13991:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    13991:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    13991:  576:    state->deckCount[player]--;
    13991:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    14602:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 4 returned 100% blocks executed 100%
        4:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
       16:  652:  for (i = 0; i < 3; i++)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -:  653:	{
       12:  654:	  drawCard(currentPlayer, state);
call    0 returned 12
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        4:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 1786 returned 100% blocks executed 100%
     1786:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
     8648:  666:	while(drawntreasure<2){
branch  0 taken 5076
branch  1 taken 1786 (fallthrough)
     5076:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 1877 (fallthrough)
branch  1 taken 3199
     1877:  668:		  shuffle(currentPlayer, state);
call    0 returned 1877
        -:  669:		}
     5076:  670:		drawCard(currentPlayer, state);
call    0 returned 5076
     5076:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     5076:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 1504 (fallthrough)
branch  1 taken 3572
branch  2 taken 1504 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 1504
     3572:  673:		  drawntreasure++;
        -:  674:		else{
     1504:  675:		  temphand[z]=cardDrawn;
     1504:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     1504:  677:		  z++;
        -:  678:		}
        -:  679:	      }
     5076:  680:	      while(z-1>=0){
branch  0 taken 1504
branch  1 taken 1786 (fallthrough)
     1504:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     1504:  682:		z=z-1;
        -:  683:	      }
     1786:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 2156 returned 100% blocks executed 82%
     2156: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     2156: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
    12936: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 10780
branch  1 taken 2156 (fallthrough)
        -: 1350:    {
    10780: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 8456 (fallthrough)
branch  1 taken 2324
        -: 1352:	{
     8456: 1353:	  state->coins += 1;
        -: 1354:	}
     2324: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 2324
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     2324: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 2324
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     2156: 1366:  state->coins += bonus;
        -: 1367:
     2156: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:
