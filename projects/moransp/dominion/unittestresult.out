-----------------------------------
TESTING shuffle() 1000 iterations:

Found 137 failures out of 38961 comparisons
File 'dominion.c'
Lines executed:16.40% of 555
Branches executed:16.31% of 417
Taken at least once:13.43% of 417
Calls executed:7.61% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 122912 returned 100% blocks executed 100%
   122912:    8:int compare(const void* a, const void* b) {
   122912:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106416
    16496:   10:    return 1;
   106416:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23811 (fallthrough)
branch  1 taken 82605
    23811:   12:    return -1;
    82605:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 999 returned 100% blocks executed 89%
      999:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      999:   44:  SelectStream(1);
call    0 returned 999
      999:   45:  PutSeed((long)randomSeed);
call    0 returned 999
        -:   46:  
        -:   47:  //check number of players
      999:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 999 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 999
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      999:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    10989:   57:  for (i = 0; i < 10; i++)
branch  0 taken 9990
branch  1 taken 999 (fallthrough)
        -:   58:    {
   109890:   59:      for (j = 0; j < 10; j++)
branch  0 taken 99900
branch  1 taken 9990 (fallthrough)
        -:   60:        {
    99900:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 89910 (fallthrough)
branch  1 taken 9990
branch  2 taken 0 (fallthrough)
branch  3 taken 89910
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      999:   73:  if (numPlayers == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 999
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
      999:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 999
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
      999:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      999:   87:  if (numPlayers == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 999
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
      999:   95:      state->supplyCount[estate] = 12;
      999:   96:      state->supplyCount[duchy] = 12;
      999:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      999:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      999:  102:  state->supplyCount[silver] = 40;
      999:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    20979:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 19980
branch  1 taken 999 (fallthrough)
        -:  107:    {
   164835:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 154845
branch  1 taken 9990 (fallthrough)
        -:  109:	{
   154845:  110:	  if (kingdomCards[j] == i)
branch  0 taken 9990 (fallthrough)
branch  1 taken 144855
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     9990:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 8991 (fallthrough)
branch  1 taken 999
branch  2 taken 999 (fallthrough)
branch  3 taken 7992
        -:  114:		{
     3996:  115:		  if (numPlayers == 2){ 
branch  0 taken 0 (fallthrough)
branch  1 taken 1998
    #####:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     1998:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     7992:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     9990:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   144855:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     4995:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3996
branch  1 taken 999 (fallthrough)
        -:  139:    {
     3996:  140:      state->deckCount[i] = 0;
    15984:  141:      for (j = 0; j < 3; j++)
branch  0 taken 11988
branch  1 taken 3996 (fallthrough)
        -:  142:	{
    11988:  143:	  state->deck[i][j] = estate;
    11988:  144:	  state->deckCount[i]++;
        -:  145:	}
    31968:  146:      for (j = 3; j < 10; j++)
branch  0 taken 27972
branch  1 taken 3996 (fallthrough)
        -:  147:	{
    27972:  148:	  state->deck[i][j] = copper;
    27972:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     4995:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3996
branch  1 taken 999 (fallthrough)
        -:  155:    {
     3996:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 3996
branch  1 taken 0 (fallthrough)
branch  2 taken 3996
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     4995:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 3996
branch  1 taken 999 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     3996:  166:      state->handCount[i] = 0;
     3996:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    27972:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 26973
branch  1 taken 999 (fallthrough)
        -:  177:    {
    26973:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      999:  182:  state->outpostPlayed = 0;
      999:  183:  state->phase = 0;
      999:  184:  state->numActions = 1;
      999:  185:  state->numBuys = 1;
      999:  186:  state->playedCardCount = 0;
      999:  187:  state->whoseTurn = 0;
      999:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     5994:  192:  for (it = 0; it < 5; it++){
branch  0 taken 4995
branch  1 taken 999 (fallthrough)
     4995:  193:    drawCard(state->whoseTurn, state);
call    0 returned 4995
        -:  194:  }
        -:  195:
      999:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 999
        -:  197:
      999:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 7992 returned 100% blocks executed 94%
     7992:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     7992:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     7992:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 7992
    #####:  210:    return -1;
     7992:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 7992
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    90909:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 74925
branch  1 taken 7992 (fallthrough)
    74925:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 74925
    74925:  216:    newDeck[newDeckPos] = state->deck[player][card];
    74925:  217:    newDeckPos++;
   241685:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 166760
branch  1 taken 74925 (fallthrough)
   166760:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    74925:  221:    state->deckCount[player]--;
        -:  222:  }
    82917:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 74925
branch  1 taken 7992 (fallthrough)
    74925:  224:    state->deck[player][i] = newDeck[i];
    74925:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     7992:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 4995 returned 100% blocks executed 38%
     4995:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     4995:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 4995
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     4995:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     4995:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     4995:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     4995:  576:    state->deckCount[player]--;
     4995:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     4995:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 0 returned 0% blocks executed 0%
    #####:  583:int getCost(int cardNumber)
        -:  584:{
    #####:  585:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
    #####:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
    #####:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
    #####: 1319:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
    #####: 1324:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
    #####: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
    #####: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
    #####: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 999 returned 100% blocks executed 82%
      999: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
      999: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     5994: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 4995
branch  1 taken 999 (fallthrough)
        -: 1350:    {
     4995: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3891 (fallthrough)
branch  1 taken 1104
        -: 1352:	{
     3891: 1353:	  state->coins += 1;
        -: 1354:	}
     1104: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1104
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1104: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1104
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
      999: 1366:  state->coins += bonus;
        -: 1367:
      999: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING buyCard()------
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:8
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:7
PASS - Expected value:7, Actual:7
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:2
PASS - Expected value:2, Actual:2
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:1
PASS - Expected value:1, Actual:1
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...Could not buy
Coins:4
PASS - Expected value:4, Actual:4
supplyCount:10
PASS - Expected value:10, Actual:10
numBuys:1
PASS - Expected value:1, Actual:1
********************************
State prior to buy card
Coins:4
supplyCount:10
numBuys:1
-------------------------------
buying card...purchase made
Coins:0
PASS - Expected value:0, Actual:0
supplyCount:9
PASS - Expected value:9, Actual:9
numBuys:0
PASS - Expected value:0, Actual:0
Failures found:0

buyCard() All Tests Passed
File 'dominion.c'
Lines executed:23.24% of 555
Branches executed:25.90% of 417
Taken at least once:18.23% of 417
Calls executed:13.04% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123212 returned 100% blocks executed 100%
   123212:    8:int compare(const void* a, const void* b) {
   123212:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106716
    16496:   10:    return 1;
   106716:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23891 (fallthrough)
branch  1 taken 82825
    23891:   12:    return -1;
    82825:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1009 returned 100% blocks executed 94%
     1009:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1009:   44:  SelectStream(1);
call    0 returned 1009
     1009:   45:  PutSeed((long)randomSeed);
call    0 returned 1009
        -:   46:  
        -:   47:  //check number of players
     1009:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1009 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1009
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1009:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11099:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10090
branch  1 taken 1009 (fallthrough)
        -:   58:    {
   110990:   59:      for (j = 0; j < 10; j++)
branch  0 taken 100900
branch  1 taken 10090 (fallthrough)
        -:   60:        {
   100900:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90810 (fallthrough)
branch  1 taken 10090
branch  2 taken 0 (fallthrough)
branch  3 taken 90810
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1009:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 999
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
      999:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 999
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
      999:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1009:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 999
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
      999:   95:      state->supplyCount[estate] = 12;
      999:   96:      state->supplyCount[duchy] = 12;
      999:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1009:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1009:  102:  state->supplyCount[silver] = 40;
     1009:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21189:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20180
branch  1 taken 1009 (fallthrough)
        -:  107:    {
   166485:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 156395
branch  1 taken 10090 (fallthrough)
        -:  109:	{
   156395:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10090 (fallthrough)
branch  1 taken 146305
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10090:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9091 (fallthrough)
branch  1 taken 999
branch  2 taken 1009 (fallthrough)
branch  3 taken 8082
        -:  114:		{
     4016:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 1998
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     1998:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8082:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10090:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146305:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5025:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  139:    {
     4016:  140:      state->deckCount[i] = 0;
    16064:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12048
branch  1 taken 4016 (fallthrough)
        -:  142:	{
    12048:  143:	  state->deck[i][j] = estate;
    12048:  144:	  state->deckCount[i]++;
        -:  145:	}
    32128:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28112
branch  1 taken 4016 (fallthrough)
        -:  147:	{
    28112:  148:	  state->deck[i][j] = copper;
    28112:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5025:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  155:    {
     4016:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4016
branch  1 taken 0 (fallthrough)
branch  2 taken 4016
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5025:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4016:  166:      state->handCount[i] = 0;
     4016:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28252:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27243
branch  1 taken 1009 (fallthrough)
        -:  177:    {
    27243:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1009:  182:  state->outpostPlayed = 0;
     1009:  183:  state->phase = 0;
     1009:  184:  state->numActions = 1;
     1009:  185:  state->numBuys = 1;
     1009:  186:  state->playedCardCount = 0;
     1009:  187:  state->whoseTurn = 0;
     1009:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6054:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5045
branch  1 taken 1009 (fallthrough)
     5045:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5045
        -:  194:  }
        -:  195:
     1009:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1009
        -:  197:
     1009:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8012 returned 100% blocks executed 94%
     8012:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8012:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8012:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8012
    #####:  210:    return -1;
     8012:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8012
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91149:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75125
branch  1 taken 8012 (fallthrough)
    75125:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75125
    75125:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75125:  217:    newDeckPos++;
   242385:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167260
branch  1 taken 75125 (fallthrough)
   167260:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75125:  221:    state->deckCount[player]--;
        -:  222:  }
    83137:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75125
branch  1 taken 8012 (fallthrough)
    75125:  224:    state->deck[player][i] = newDeck[i];
    75125:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8012:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5045 returned 100% blocks executed 38%
     5045:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5045:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5045
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5045:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5045:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5045:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5045:  576:    state->deckCount[player]--;
     5045:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5045:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 16 returned 100% blocks executed 40%
       16:  583:int getCost(int cardNumber)
        -:  584:{
       16:  585:  switch( cardNumber ) 
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 1
branch  8 taken 0
branch  9 taken 0
branch 10 taken 2
branch 11 taken 1
branch 12 taken 0
branch 13 taken 2
branch 14 taken 2
branch 15 taken 0
branch 16 taken 0
branch 17 taken 1
branch 18 taken 0
branch 19 taken 1
branch 20 taken 0
branch 21 taken 2
branch 22 taken 2
branch 23 taken 0
branch 24 taken 0
branch 25 taken 2
branch 26 taken 0
branch 27 taken 0
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
        2:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
        2:  614:      return 4;
        -:  615:    case village:
        2:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
        2:  630:      return 4;
        -:  631:    case embargo: 
        2:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
        2:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1009 returned 100% blocks executed 82%
     1009: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1009: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6054: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5045
branch  1 taken 1009 (fallthrough)
        -: 1350:    {
     5045: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3931 (fallthrough)
branch  1 taken 1114
        -: 1352:	{
     3931: 1353:	  state->coins += 1;
        -: 1354:	}
     1114: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1114
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1114: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1114
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1009: 1366:  state->coins += bonus;
        -: 1367:
     1009: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:
PASS - Expected value:0, Actual:0
PASS - Expected value:2, Actual:2
PASS - Expected value:5, Actual:5
PASS - Expected value:8, Actual:8
PASS - Expected value:0, Actual:0
PASS - Expected value:3, Actual:3
PASS - Expected value:6, Actual:6
PASS - Expected value:6, Actual:6
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:3, Actual:3
PASS - Expected value:4, Actual:4
PASS - Expected value:3, Actual:3
PASS - Expected value:5, Actual:5
PASS - Expected value:3, Actual:3
PASS - Expected value:5, Actual:5
PASS - Expected value:3, Actual:3
PASS - Expected value:4, Actual:4
PASS - Expected value:2, Actual:2
PASS - Expected value:5, Actual:5
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:4, Actual:4
PASS - Expected value:0, Actual:0
PASS - Expected value:-1, Actual:-1
PASS - Expected value:-1, Actual:-1
Values checked report(s) 0 errors
All tests passed
File 'dominion.c'
Lines executed:26.49% of 555
Branches executed:25.90% of 417
Taken at least once:22.54% of 417
Calls executed:13.04% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123212 returned 100% blocks executed 100%
   123212:    8:int compare(const void* a, const void* b) {
   123212:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106716
    16496:   10:    return 1;
   106716:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23891 (fallthrough)
branch  1 taken 82825
    23891:   12:    return -1;
    82825:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1009 returned 100% blocks executed 94%
     1009:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1009:   44:  SelectStream(1);
call    0 returned 1009
     1009:   45:  PutSeed((long)randomSeed);
call    0 returned 1009
        -:   46:  
        -:   47:  //check number of players
     1009:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1009 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1009
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1009:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11099:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10090
branch  1 taken 1009 (fallthrough)
        -:   58:    {
   110990:   59:      for (j = 0; j < 10; j++)
branch  0 taken 100900
branch  1 taken 10090 (fallthrough)
        -:   60:        {
   100900:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90810 (fallthrough)
branch  1 taken 10090
branch  2 taken 0 (fallthrough)
branch  3 taken 90810
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1009:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 999
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
      999:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 999
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
      999:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1009:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 999
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
      999:   95:      state->supplyCount[estate] = 12;
      999:   96:      state->supplyCount[duchy] = 12;
      999:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1009:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1009:  102:  state->supplyCount[silver] = 40;
     1009:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21189:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20180
branch  1 taken 1009 (fallthrough)
        -:  107:    {
   166485:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 156395
branch  1 taken 10090 (fallthrough)
        -:  109:	{
   156395:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10090 (fallthrough)
branch  1 taken 146305
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10090:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9091 (fallthrough)
branch  1 taken 999
branch  2 taken 1009 (fallthrough)
branch  3 taken 8082
        -:  114:		{
     4016:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 1998
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     1998:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8082:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10090:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146305:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5025:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  139:    {
     4016:  140:      state->deckCount[i] = 0;
    16064:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12048
branch  1 taken 4016 (fallthrough)
        -:  142:	{
    12048:  143:	  state->deck[i][j] = estate;
    12048:  144:	  state->deckCount[i]++;
        -:  145:	}
    32128:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28112
branch  1 taken 4016 (fallthrough)
        -:  147:	{
    28112:  148:	  state->deck[i][j] = copper;
    28112:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5025:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  155:    {
     4016:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4016
branch  1 taken 0 (fallthrough)
branch  2 taken 4016
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5025:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4016
branch  1 taken 1009 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4016:  166:      state->handCount[i] = 0;
     4016:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28252:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27243
branch  1 taken 1009 (fallthrough)
        -:  177:    {
    27243:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1009:  182:  state->outpostPlayed = 0;
     1009:  183:  state->phase = 0;
     1009:  184:  state->numActions = 1;
     1009:  185:  state->numBuys = 1;
     1009:  186:  state->playedCardCount = 0;
     1009:  187:  state->whoseTurn = 0;
     1009:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6054:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5045
branch  1 taken 1009 (fallthrough)
     5045:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5045
        -:  194:  }
        -:  195:
     1009:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1009
        -:  197:
     1009:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8012 returned 100% blocks executed 94%
     8012:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8012:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8012:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8012
    #####:  210:    return -1;
     8012:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8012
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91149:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75125
branch  1 taken 8012 (fallthrough)
    75125:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75125
    75125:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75125:  217:    newDeckPos++;
   242385:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167260
branch  1 taken 75125 (fallthrough)
   167260:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75125:  221:    state->deckCount[player]--;
        -:  222:  }
    83137:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75125
branch  1 taken 8012 (fallthrough)
    75125:  224:    state->deck[player][i] = newDeck[i];
    75125:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8012:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5045 returned 100% blocks executed 38%
     5045:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5045:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5045
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5045:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5045:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5045:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5045:  576:    state->deckCount[player]--;
     5045:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5045:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1009 returned 100% blocks executed 82%
     1009: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1009: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6054: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5045
branch  1 taken 1009 (fallthrough)
        -: 1350:    {
     5045: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3931 (fallthrough)
branch  1 taken 1114
        -: 1352:	{
     3931: 1353:	  state->coins += 1;
        -: 1354:	}
     1114: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1114
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1114: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1114
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1009: 1366:  state->coins += bonus;
        -: 1367:
     1009: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING endTurn()------
********************************
it is currently player 0's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:1, Actual:1
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
********************************
it is currently player 1's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:2, Actual:2
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		FAIL - Expected value: 3, Actual: 4
********************************
it is currently player 2's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:3, Actual:3
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
********************************
it is currently player 3's turn
-------------------------------
ending turn...	
-------------------------------
PASS - Expected value:0, Actual:0
phase		PASS - Expected value:0, Actual:0
numActions	PASS - Expected value:1, Actual:1
numBuys		PASS - Expected value:1, Actual:1
playedCardCount	PASS - Expected value:0, Actual:0
handCount	PASS - Expected value:0, Actual:0
coins		PASS - Expected value:3, Actual:3
Failures found:1
File 'dominion.c'
Lines executed:30.45% of 555
Branches executed:27.34% of 417
Taken at least once:23.98% of 417
Calls executed:16.30% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:4
        -:    0:Programs:4
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123272 returned 100% blocks executed 100%
   123272:    8:int compare(const void* a, const void* b) {
   123272:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106776
    16496:   10:    return 1;
   106776:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23907 (fallthrough)
branch  1 taken 82869
    23907:   12:    return -1;
    82869:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1010 returned 100% blocks executed 94%
     1010:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1010:   44:  SelectStream(1);
call    0 returned 1010
     1010:   45:  PutSeed((long)randomSeed);
call    0 returned 1010
        -:   46:  
        -:   47:  //check number of players
     1010:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1010 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1010
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1010:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11110:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10100
branch  1 taken 1010 (fallthrough)
        -:   58:    {
   111100:   59:      for (j = 0; j < 10; j++)
branch  0 taken 101000
branch  1 taken 10100 (fallthrough)
        -:   60:        {
   101000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90900 (fallthrough)
branch  1 taken 10100
branch  2 taken 0 (fallthrough)
branch  3 taken 90900
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1010:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1000
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     1000:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 1000
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     1000:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1010:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1000
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     1000:   95:      state->supplyCount[estate] = 12;
     1000:   96:      state->supplyCount[duchy] = 12;
     1000:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1010:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1010:  102:  state->supplyCount[silver] = 40;
     1010:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21210:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20200
branch  1 taken 1010 (fallthrough)
        -:  107:    {
   166650:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 156550
branch  1 taken 10100 (fallthrough)
        -:  109:	{
   156550:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10100 (fallthrough)
branch  1 taken 146450
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10100:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9101 (fallthrough)
branch  1 taken 999
branch  2 taken 1010 (fallthrough)
branch  3 taken 8091
        -:  114:		{
     4018:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 1999
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     1999:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8091:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10100:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146450:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5030:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4020
branch  1 taken 1010 (fallthrough)
        -:  139:    {
     4020:  140:      state->deckCount[i] = 0;
    16080:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12060
branch  1 taken 4020 (fallthrough)
        -:  142:	{
    12060:  143:	  state->deck[i][j] = estate;
    12060:  144:	  state->deckCount[i]++;
        -:  145:	}
    32160:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28140
branch  1 taken 4020 (fallthrough)
        -:  147:	{
    28140:  148:	  state->deck[i][j] = copper;
    28140:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5030:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4020
branch  1 taken 1010 (fallthrough)
        -:  155:    {
     4020:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4020
branch  1 taken 0 (fallthrough)
branch  2 taken 4020
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5030:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4020
branch  1 taken 1010 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4020:  166:      state->handCount[i] = 0;
     4020:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28280:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27270
branch  1 taken 1010 (fallthrough)
        -:  177:    {
    27270:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1010:  182:  state->outpostPlayed = 0;
     1010:  183:  state->phase = 0;
     1010:  184:  state->numActions = 1;
     1010:  185:  state->numBuys = 1;
     1010:  186:  state->playedCardCount = 0;
     1010:  187:  state->whoseTurn = 0;
     1010:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6060:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5050
branch  1 taken 1010 (fallthrough)
     5050:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5050
        -:  194:  }
        -:  195:
     1010:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1010
        -:  197:
     1010:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8016 returned 100% blocks executed 94%
     8016:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8016:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8016:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8016
    #####:  210:    return -1;
     8016:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8016
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91197:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75165
branch  1 taken 8016 (fallthrough)
    75165:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75165
    75165:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75165:  217:    newDeckPos++;
   242524:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167359
branch  1 taken 75165 (fallthrough)
   167359:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75165:  221:    state->deckCount[player]--;
        -:  222:  }
    83181:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75165
branch  1 taken 8016 (fallthrough)
    75165:  224:    state->deck[player][i] = newDeck[i];
    75165:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8016:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5070 returned 100% blocks executed 38%
     5070:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5070:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5070
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5070:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5070:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5070:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5070:  576:    state->deckCount[player]--;
     5070:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5070:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 0 returned 0% blocks executed 0%
    #####:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
    #####:  652:  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  653:	{
    #####:  654:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
    #####:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1014 returned 100% blocks executed 82%
     1014: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1014: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6084: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5070
branch  1 taken 1014 (fallthrough)
        -: 1350:    {
     5070: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3948 (fallthrough)
branch  1 taken 1122
        -: 1352:	{
     3948: 1353:	  state->coins += 1;
        -: 1354:	}
     1122: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1122
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1122: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1122
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1014: 1366:  state->coins += bonus;
        -: 1367:
     1014: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:31.17% of 555
Branches executed:27.82% of 417
Taken at least once:24.46% of 417
Calls executed:17.39% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123332 returned 100% blocks executed 100%
   123332:    8:int compare(const void* a, const void* b) {
   123332:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106836
    16496:   10:    return 1;
   106836:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23923 (fallthrough)
branch  1 taken 82913
    23923:   12:    return -1;
    82913:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1011 returned 100% blocks executed 94%
     1011:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1011:   44:  SelectStream(1);
call    0 returned 1011
     1011:   45:  PutSeed((long)randomSeed);
call    0 returned 1011
        -:   46:  
        -:   47:  //check number of players
     1011:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1011 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1011
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1011:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11121:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10110
branch  1 taken 1011 (fallthrough)
        -:   58:    {
   111210:   59:      for (j = 0; j < 10; j++)
branch  0 taken 101100
branch  1 taken 10110 (fallthrough)
        -:   60:        {
   101100:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90990 (fallthrough)
branch  1 taken 10110
branch  2 taken 0 (fallthrough)
branch  3 taken 90990
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1011:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1001
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     1001:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 1001
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     1001:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1011:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1001
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     1001:   95:      state->supplyCount[estate] = 12;
     1001:   96:      state->supplyCount[duchy] = 12;
     1001:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1011:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1011:  102:  state->supplyCount[silver] = 40;
     1011:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21231:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20220
branch  1 taken 1011 (fallthrough)
        -:  107:    {
   166815:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 156705
branch  1 taken 10110 (fallthrough)
        -:  109:	{
   156705:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10110 (fallthrough)
branch  1 taken 146595
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10110:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9111 (fallthrough)
branch  1 taken 999
branch  2 taken 1011 (fallthrough)
branch  3 taken 8100
        -:  114:		{
     4020:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 2000
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     2000:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8100:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10110:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146595:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5035:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4024
branch  1 taken 1011 (fallthrough)
        -:  139:    {
     4024:  140:      state->deckCount[i] = 0;
    16096:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12072
branch  1 taken 4024 (fallthrough)
        -:  142:	{
    12072:  143:	  state->deck[i][j] = estate;
    12072:  144:	  state->deckCount[i]++;
        -:  145:	}
    32192:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28168
branch  1 taken 4024 (fallthrough)
        -:  147:	{
    28168:  148:	  state->deck[i][j] = copper;
    28168:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5035:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4024
branch  1 taken 1011 (fallthrough)
        -:  155:    {
     4024:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4024
branch  1 taken 0 (fallthrough)
branch  2 taken 4024
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5035:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4024
branch  1 taken 1011 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4024:  166:      state->handCount[i] = 0;
     4024:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28308:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27297
branch  1 taken 1011 (fallthrough)
        -:  177:    {
    27297:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1011:  182:  state->outpostPlayed = 0;
     1011:  183:  state->phase = 0;
     1011:  184:  state->numActions = 1;
     1011:  185:  state->numBuys = 1;
     1011:  186:  state->playedCardCount = 0;
     1011:  187:  state->whoseTurn = 0;
     1011:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6066:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5055
branch  1 taken 1011 (fallthrough)
     5055:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5055
        -:  194:  }
        -:  195:
     1011:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1011
        -:  197:
     1011:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8020 returned 100% blocks executed 94%
     8020:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8020:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8020:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8020
    #####:  210:    return -1;
     8020:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8020
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91245:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75205
branch  1 taken 8020 (fallthrough)
    75205:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75205
    75205:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75205:  217:    newDeckPos++;
   242663:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167458
branch  1 taken 75205 (fallthrough)
   167458:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75205:  221:    state->deckCount[player]--;
        -:  222:  }
    83225:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75205
branch  1 taken 8020 (fallthrough)
    75205:  224:    state->deck[player][i] = newDeck[i];
    75205:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8020:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5078 returned 100% blocks executed 38%
     5078:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5078:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5078
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5078:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5078:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5078:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5078:  576:    state->deckCount[player]--;
     5078:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5078:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 1 returned 100% blocks executed 100%
        1:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
        4:  652:  for (i = 0; i < 3; i++)
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        -:  653:	{
        3:  654:	  drawCard(currentPlayer, state);
call    0 returned 3
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        1:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1015 returned 100% blocks executed 82%
     1015: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1015: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6090: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5075
branch  1 taken 1015 (fallthrough)
        -: 1350:    {
     5075: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3952 (fallthrough)
branch  1 taken 1123
        -: 1352:	{
     3952: 1353:	  state->coins += 1;
        -: 1354:	}
     1123: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1123
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1123: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1123
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1015: 1366:  state->coins += bonus;
        -: 1367:
     1015: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:31.17% of 555
Branches executed:27.82% of 417
Taken at least once:24.46% of 417
Calls executed:17.39% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:6
        -:    0:Programs:6
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123392 returned 100% blocks executed 100%
   123392:    8:int compare(const void* a, const void* b) {
   123392:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106896
    16496:   10:    return 1;
   106896:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23939 (fallthrough)
branch  1 taken 82957
    23939:   12:    return -1;
    82957:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1012 returned 100% blocks executed 94%
     1012:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1012:   44:  SelectStream(1);
call    0 returned 1012
     1012:   45:  PutSeed((long)randomSeed);
call    0 returned 1012
        -:   46:  
        -:   47:  //check number of players
     1012:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1012 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1012
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1012:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11132:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10120
branch  1 taken 1012 (fallthrough)
        -:   58:    {
   111320:   59:      for (j = 0; j < 10; j++)
branch  0 taken 101200
branch  1 taken 10120 (fallthrough)
        -:   60:        {
   101200:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 91080 (fallthrough)
branch  1 taken 10120
branch  2 taken 0 (fallthrough)
branch  3 taken 91080
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1012:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1002
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     1002:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 1002
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     1002:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1012:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1002
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     1002:   95:      state->supplyCount[estate] = 12;
     1002:   96:      state->supplyCount[duchy] = 12;
     1002:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1012:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1012:  102:  state->supplyCount[silver] = 40;
     1012:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21252:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20240
branch  1 taken 1012 (fallthrough)
        -:  107:    {
   166980:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 156860
branch  1 taken 10120 (fallthrough)
        -:  109:	{
   156860:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10120 (fallthrough)
branch  1 taken 146740
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10120:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9121 (fallthrough)
branch  1 taken 999
branch  2 taken 1012 (fallthrough)
branch  3 taken 8109
        -:  114:		{
     4022:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 2001
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     2001:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8109:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10120:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146740:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5040:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4028
branch  1 taken 1012 (fallthrough)
        -:  139:    {
     4028:  140:      state->deckCount[i] = 0;
    16112:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12084
branch  1 taken 4028 (fallthrough)
        -:  142:	{
    12084:  143:	  state->deck[i][j] = estate;
    12084:  144:	  state->deckCount[i]++;
        -:  145:	}
    32224:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28196
branch  1 taken 4028 (fallthrough)
        -:  147:	{
    28196:  148:	  state->deck[i][j] = copper;
    28196:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5040:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4028
branch  1 taken 1012 (fallthrough)
        -:  155:    {
     4028:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4028
branch  1 taken 0 (fallthrough)
branch  2 taken 4028
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5040:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4028
branch  1 taken 1012 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4028:  166:      state->handCount[i] = 0;
     4028:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28336:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27324
branch  1 taken 1012 (fallthrough)
        -:  177:    {
    27324:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1012:  182:  state->outpostPlayed = 0;
     1012:  183:  state->phase = 0;
     1012:  184:  state->numActions = 1;
     1012:  185:  state->numBuys = 1;
     1012:  186:  state->playedCardCount = 0;
     1012:  187:  state->whoseTurn = 0;
     1012:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6072:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5060
branch  1 taken 1012 (fallthrough)
     5060:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5060
        -:  194:  }
        -:  195:
     1012:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1012
        -:  197:
     1012:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8024 returned 100% blocks executed 94%
     8024:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8024:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8024:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8024
    #####:  210:    return -1;
     8024:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8024
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91293:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75245
branch  1 taken 8024 (fallthrough)
    75245:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75245
    75245:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75245:  217:    newDeckPos++;
   242802:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167557
branch  1 taken 75245 (fallthrough)
   167557:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75245:  221:    state->deckCount[player]--;
        -:  222:  }
    83269:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75245
branch  1 taken 8024 (fallthrough)
    75245:  224:    state->deck[player][i] = newDeck[i];
    75245:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8024:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5086 returned 100% blocks executed 38%
     5086:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5086:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5086
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5086:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5086:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5086:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5086:  576:    state->deckCount[player]--;
     5086:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5086:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 2 returned 100% blocks executed 100%
        2:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
        8:  652:  for (i = 0; i < 3; i++)
branch  0 taken 6
branch  1 taken 2 (fallthrough)
        -:  653:	{
        6:  654:	  drawCard(currentPlayer, state);
call    0 returned 6
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        2:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1016 returned 100% blocks executed 82%
     1016: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1016: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6096: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5080
branch  1 taken 1016 (fallthrough)
        -: 1350:    {
     5080: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3956 (fallthrough)
branch  1 taken 1124
        -: 1352:	{
     3956: 1353:	  state->coins += 1;
        -: 1354:	}
     1124: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1124
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1124: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1124
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1016: 1366:  state->coins += bonus;
        -: 1367:
     1016: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:31.17% of 555
Branches executed:27.82% of 417
Taken at least once:24.46% of 417
Calls executed:17.39% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123452 returned 100% blocks executed 100%
   123452:    8:int compare(const void* a, const void* b) {
   123452:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 106956
    16496:   10:    return 1;
   106956:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23955 (fallthrough)
branch  1 taken 83001
    23955:   12:    return -1;
    83001:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1013 returned 100% blocks executed 94%
     1013:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1013:   44:  SelectStream(1);
call    0 returned 1013
     1013:   45:  PutSeed((long)randomSeed);
call    0 returned 1013
        -:   46:  
        -:   47:  //check number of players
     1013:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1013 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1013
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1013:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11143:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10130
branch  1 taken 1013 (fallthrough)
        -:   58:    {
   111430:   59:      for (j = 0; j < 10; j++)
branch  0 taken 101300
branch  1 taken 10130 (fallthrough)
        -:   60:        {
   101300:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 91170 (fallthrough)
branch  1 taken 10130
branch  2 taken 0 (fallthrough)
branch  3 taken 91170
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1013:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1003
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     1003:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 1003
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     1003:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1013:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1003
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     1003:   95:      state->supplyCount[estate] = 12;
     1003:   96:      state->supplyCount[duchy] = 12;
     1003:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1013:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1013:  102:  state->supplyCount[silver] = 40;
     1013:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21273:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20260
branch  1 taken 1013 (fallthrough)
        -:  107:    {
   167145:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 157015
branch  1 taken 10130 (fallthrough)
        -:  109:	{
   157015:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10130 (fallthrough)
branch  1 taken 146885
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10130:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9131 (fallthrough)
branch  1 taken 999
branch  2 taken 1013 (fallthrough)
branch  3 taken 8118
        -:  114:		{
     4024:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 2002
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     2002:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8118:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10130:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   146885:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5045:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4032
branch  1 taken 1013 (fallthrough)
        -:  139:    {
     4032:  140:      state->deckCount[i] = 0;
    16128:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12096
branch  1 taken 4032 (fallthrough)
        -:  142:	{
    12096:  143:	  state->deck[i][j] = estate;
    12096:  144:	  state->deckCount[i]++;
        -:  145:	}
    32256:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28224
branch  1 taken 4032 (fallthrough)
        -:  147:	{
    28224:  148:	  state->deck[i][j] = copper;
    28224:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5045:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4032
branch  1 taken 1013 (fallthrough)
        -:  155:    {
     4032:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4032
branch  1 taken 0 (fallthrough)
branch  2 taken 4032
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5045:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4032
branch  1 taken 1013 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4032:  166:      state->handCount[i] = 0;
     4032:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28364:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27351
branch  1 taken 1013 (fallthrough)
        -:  177:    {
    27351:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1013:  182:  state->outpostPlayed = 0;
     1013:  183:  state->phase = 0;
     1013:  184:  state->numActions = 1;
     1013:  185:  state->numBuys = 1;
     1013:  186:  state->playedCardCount = 0;
     1013:  187:  state->whoseTurn = 0;
     1013:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6078:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5065
branch  1 taken 1013 (fallthrough)
     5065:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5065
        -:  194:  }
        -:  195:
     1013:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1013
        -:  197:
     1013:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8028 returned 100% blocks executed 94%
     8028:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8028:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8028:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8028
    #####:  210:    return -1;
     8028:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8028
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91341:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75285
branch  1 taken 8028 (fallthrough)
    75285:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75285
    75285:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75285:  217:    newDeckPos++;
   242941:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167656
branch  1 taken 75285 (fallthrough)
   167656:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75285:  221:    state->deckCount[player]--;
        -:  222:  }
    83313:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75285
branch  1 taken 8028 (fallthrough)
    75285:  224:    state->deck[player][i] = newDeck[i];
    75285:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8028:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5094 returned 100% blocks executed 38%
     5094:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5094:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5094
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5094:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5094:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5094:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5094:  576:    state->deckCount[player]--;
     5094:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5094:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 3 returned 100% blocks executed 100%
        3:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
       12:  652:  for (i = 0; i < 3; i++)
branch  0 taken 9
branch  1 taken 3 (fallthrough)
        -:  653:	{
        9:  654:	  drawCard(currentPlayer, state);
call    0 returned 9
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        3:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1017 returned 100% blocks executed 82%
     1017: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1017: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6102: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5085
branch  1 taken 1017 (fallthrough)
        -: 1350:    {
     5085: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3960 (fallthrough)
branch  1 taken 1125
        -: 1352:	{
     3960: 1353:	  state->coins += 1;
        -: 1354:	}
     1125: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1125
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1125: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1125
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1017: 1366:  state->coins += bonus;
        -: 1367:
     1017: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:

------TESTING card: Smithy()------
hand size currentPlayer: 5
deck size currentPlayer: 5
discard size currentPlayer: 0
[36mTESTING:[0m smithy status return---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m smithy hand size---
[31mFAIL - Expected value: 7, Actual: 8
[36mTESTING:[0m smithy discard pile---
[31mFAIL - Expected value: 1, Actual: 0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Hand Count other players:---
[32mPASS - Expected value:0, Actual:0
[36mTESTING:[0m Deck Count other players:---
[32mPASS - Expected value:10, Actual:10
[36mTESTING:[0m Discard Count other players---
[32mPASS - Expected value:0, Actual:0
[0m
File 'dominion.c'
Lines executed:31.17% of 555
Branches executed:27.82% of 417
Taken at least once:24.46% of 417
Calls executed:17.39% of 92
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 123512 returned 100% blocks executed 100%
   123512:    8:int compare(const void* a, const void* b) {
   123512:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 16496 (fallthrough)
branch  1 taken 107016
    16496:   10:    return 1;
   107016:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 23971 (fallthrough)
branch  1 taken 83045
    23971:   12:    return -1;
    83045:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1014 returned 100% blocks executed 94%
     1014:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
     1014:   44:  SelectStream(1);
call    0 returned 1014
     1014:   45:  PutSeed((long)randomSeed);
call    0 returned 1014
        -:   46:  
        -:   47:  //check number of players
     1014:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 1014 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1014
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
     1014:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    11154:   57:  for (i = 0; i < 10; i++)
branch  0 taken 10140
branch  1 taken 1014 (fallthrough)
        -:   58:    {
   111540:   59:      for (j = 0; j < 10; j++)
branch  0 taken 101400
branch  1 taken 10140 (fallthrough)
        -:   60:        {
   101400:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 91260 (fallthrough)
branch  1 taken 10140
branch  2 taken 0 (fallthrough)
branch  3 taken 91260
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
     1014:   73:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1004
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
     1004:   77:  else if (numPlayers == 3)
branch  0 taken 0 (fallthrough)
branch  1 taken 1004
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
     1004:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
     1014:   87:  if (numPlayers == 2)
branch  0 taken 10 (fallthrough)
branch  1 taken 1004
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
     1004:   95:      state->supplyCount[estate] = 12;
     1004:   96:      state->supplyCount[duchy] = 12;
     1004:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
     1014:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
     1014:  102:  state->supplyCount[silver] = 40;
     1014:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    21294:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 20280
branch  1 taken 1014 (fallthrough)
        -:  107:    {
   167310:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 157170
branch  1 taken 10140 (fallthrough)
        -:  109:	{
   157170:  110:	  if (kingdomCards[j] == i)
branch  0 taken 10140 (fallthrough)
branch  1 taken 147030
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    10140:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 9141 (fallthrough)
branch  1 taken 999
branch  2 taken 1014 (fallthrough)
branch  3 taken 8127
        -:  114:		{
     4026:  115:		  if (numPlayers == 2){ 
branch  0 taken 10 (fallthrough)
branch  1 taken 2003
       10:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
     2003:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     8127:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    10140:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
   147030:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     5050:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4036
branch  1 taken 1014 (fallthrough)
        -:  139:    {
     4036:  140:      state->deckCount[i] = 0;
    16144:  141:      for (j = 0; j < 3; j++)
branch  0 taken 12108
branch  1 taken 4036 (fallthrough)
        -:  142:	{
    12108:  143:	  state->deck[i][j] = estate;
    12108:  144:	  state->deckCount[i]++;
        -:  145:	}
    32288:  146:      for (j = 3; j < 10; j++)
branch  0 taken 28252
branch  1 taken 4036 (fallthrough)
        -:  147:	{
    28252:  148:	  state->deck[i][j] = copper;
    28252:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     5050:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4036
branch  1 taken 1014 (fallthrough)
        -:  155:    {
     4036:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 4036
branch  1 taken 0 (fallthrough)
branch  2 taken 4036
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     5050:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 4036
branch  1 taken 1014 (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     4036:  166:      state->handCount[i] = 0;
     4036:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    28392:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 27378
branch  1 taken 1014 (fallthrough)
        -:  177:    {
    27378:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
     1014:  182:  state->outpostPlayed = 0;
     1014:  183:  state->phase = 0;
     1014:  184:  state->numActions = 1;
     1014:  185:  state->numBuys = 1;
     1014:  186:  state->playedCardCount = 0;
     1014:  187:  state->whoseTurn = 0;
     1014:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     6084:  192:  for (it = 0; it < 5; it++){
branch  0 taken 5070
branch  1 taken 1014 (fallthrough)
     5070:  193:    drawCard(state->whoseTurn, state);
call    0 returned 5070
        -:  194:  }
        -:  195:
     1014:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 1014
        -:  197:
     1014:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 8032 returned 100% blocks executed 94%
     8032:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     8032:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     8032:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8032
    #####:  210:    return -1;
     8032:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 8032
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    91389:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 75325
branch  1 taken 8032 (fallthrough)
    75325:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 75325
    75325:  216:    newDeck[newDeckPos] = state->deck[player][card];
    75325:  217:    newDeckPos++;
   243080:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 167755
branch  1 taken 75325 (fallthrough)
   167755:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    75325:  221:    state->deckCount[player]--;
        -:  222:  }
    83357:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 75325
branch  1 taken 8032 (fallthrough)
    75325:  224:    state->deck[player][i] = newDeck[i];
    75325:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     8032:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 10 returned 100% blocks executed 86%
       10:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
       10:  280:  who = state->whoseTurn;
        -:  281:
       10:  282:  if (state->numBuys < 1){
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
       10:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
       10:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 10
branch  1 taken 4 (fallthrough)
branch  2 taken 6
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        4:  293:    return -1;
        -:  294:  } else {
        6:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
        6:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 6
        -:  298:  
        6:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 6
        6:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
        6:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 16 returned 100% blocks executed 100%
       16:  320:int supplyCount(int card, struct gameState *state) {
       16:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 4 returned 100% blocks executed 100%
        4:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
        4:  353:  int currentPlayer = whoseTurn(state);
call    0 returned 4
        -:  354:  
        -:  355:  //Discard hand
       24:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       20:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
        4:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
        4:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
        1:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
        4:  370:  state->outpostPlayed = 0;
        4:  371:  state->phase = 0;
        4:  372:  state->numActions = 1;
        4:  373:  state->coins = 0;
        4:  374:  state->numBuys = 1;
        4:  375:  state->playedCardCount = 0;
        4:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
       24:  380:  for (k = 0; k < 5; k++){
branch  0 taken 20
branch  1 taken 4 (fallthrough)
       20:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 returned 20
        -:  382:  }
        -:  383:
        -:  384:  //Update money
        4:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 returned 4
        -:  386:
        4:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 5102 returned 100% blocks executed 38%
     5102:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     5102:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0 (fallthrough)
branch  1 taken 5102
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     5102:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     5102:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     5102:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     5102:  576:    state->deckCount[player]--;
     5102:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     5102:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 46 returned 100% blocks executed 100%
       46:  583:int getCost(int cardNumber)
        -:  584:{
       46:  585:  switch( cardNumber ) 
branch  0 taken 2
branch  1 taken 1
branch  2 taken 1
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 2
branch  8 taken 1
branch  9 taken 1
branch 10 taken 3
branch 11 taken 2
branch 12 taken 1
branch 13 taken 3
branch 14 taken 3
branch 15 taken 1
branch 16 taken 1
branch 17 taken 2
branch 18 taken 1
branch 19 taken 2
branch 20 taken 1
branch 21 taken 3
branch 22 taken 3
branch 23 taken 1
branch 24 taken 1
branch 25 taken 3
branch 26 taken 1
branch 27 taken 2
        -:  586:    {
        -:  587:    case curse:
        2:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        2:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        3:  608:      return 4;
        -:  609:    case mine:
        2:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        3:  614:      return 4;
        -:  615:    case village:
        3:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        2:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        2:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        3:  630:      return 4;
        -:  631:    case embargo: 
        3:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        3:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        2:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:/* MORANSP CHANGES*/
        -:  647://SMITHY
function dom_smithy called 4 returned 100% blocks executed 100%
        4:  648:int dom_smithy(int handPos, int currentPlayer, struct gameState *state)
        -:  649:{
        -:  650:  int i;
        -:  651:  //+3 Cards
       16:  652:  for (i = 0; i < 3; i++)
branch  0 taken 12
branch  1 taken 4 (fallthrough)
        -:  653:	{
       12:  654:	  drawCard(currentPlayer, state);
call    0 returned 12
        -:  655:	}
        -:  656:			
        -:  657:      //discard card from handi\
        -:  658:      discardCard(handPos, currentPlayer, state, 0);
        4:  659:      return 0;
        -:  660:}
        -:  661://END SMITHY
        -:  662:
        -:  663://ADVENTURER
function dom_adventurer called 0 returned 0% blocks executed 0%
    #####:  664:int dom_adventurer(int cardDrawn, int drawntreasure, int currentPlayer, int *temphand, struct gameState *state, int z)
        -:  665:{ 
    #####:  666:	while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  667:		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:		  shuffle(currentPlayer, state);
call    0 never executed
        -:  669:		}
    #####:  670:		drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		  drawntreasure++;
        -:  674:		else{
    #####:  675:		  temphand[z]=cardDrawn;
    #####:  676:		  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:		  z++;
        -:  678:		}
        -:  679:	      }
    #####:  680:	      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:		z=z-1;
        -:  683:	      }
    #####:  684:	      return 1;
        -:  685:}
        -:  686://END ADVENTURER
        -:  687:
        -:  688://VILLAGE
function dom_village called 0 returned 0% blocks executed 0%
    #####:  689:int dom_village(int handPos, int currentPlayer, struct gameState *state)
        -:  690:{
        -:  691:      //+1 Card
    #####:  692:      drawCard(currentPlayer, state);
call    0 never executed
        -:  693:			
        -:  694:      //+2 Actions
    #####:  695:      state->numActions = state->numActions + 3;
        -:  696:			
        -:  697:      //discard played card from hand\
        -:  698:      discardCard(handPos, currentPlayer, state, 0);
    #####:  699:      return 0;
        -:  700:}
        -:  701://END VILLAGE
        -:  702:
        -:  703://OUTPOST
function dom_outpost called 0 returned 0% blocks executed 0%
    #####:  704:int dom_outpost(int handPos, int currentPlayer, struct gameState *state)
        -:  705:{
        -:  706:      //set outpost flag
    #####:  707:      state->outpostPlayed++;
        -:  708:			
        -:  709:      //discard card\
        -:  710:      discardCard(handPos, currentPlayer, state, 0);
    #####:  711:      return 1;
        -:  712:}
        -:  713://END OUTPOST
        -:  714:
        -:  715://EMBARGO
function dom_embargo called 0 returned 0% blocks executed 0%
    #####:  716:int dom_embargo(int choice1, int handPos, int currentPlayer, struct gameState *state)
        -:  717:{
        -:  718:      //+2 Coins
    #####:  719:      state->coins = state->coins + 2;
        -:  720:			
        -:  721:      //see if selected pile is in play
    #####:  722:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  723:	{
    #####:  724:	  return -1;
        -:  725:	}
        -:  726:			
        -:  727:      //add embargo token to selected supply pile
    #####:  728:      state->embargoTokens[choice1]++;
        -:  729:			
        -:  730:      //trash card
    #####:  731:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  732:      return 0;
        -:  733:	
        -:  734:}
        -:  735://END EMBARGO
        -:  736:/* END MORANSP CHANGES */
        -:  737:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  738:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  739:{
        -:  740:  int i;
        -:  741:  int j;
        -:  742:  int k;
        -:  743:  int x;
        -:  744:  int index;
    #####:  745:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  746:  int nextPlayer = currentPlayer + 1;
        -:  747:
    #####:  748:  int tributeRevealedCards[2] = {-1, -1};
        -:  749:  int temphand[MAX_HAND];// moved above the if statement
    #####:  750:  int drawntreasure=0;
        -:  751:  int cardDrawn;
    #####:  752:  int z = 0;// this is the counter for the temp hand
    #####:  753:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  754:    nextPlayer = 0;
        -:  755:  }
        -:  756:  
        -:  757:	
        -:  758:  //uses switch to select card and perform actions
    #####:  759:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  760:    {
        -:  761:    case adventurer:
        -:  762:	//edited to single function
    #####:  763:	return dom_adventurer(cardDrawn, drawntreasure, currentPlayer, temphand, state, z);
call    0 never executed
        -:  764:		
        -:  765:    case council_room:
        -:  766:      //+4 Cards
    #####:  767:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  768:	{
    #####:  769:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  770:	}
        -:  771:			
        -:  772:      //+1 Buy
    #####:  773:      state->numBuys++;
        -:  774:			
        -:  775:      //Each other player draws a card
    #####:  776:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  777:	{
    #####:  778:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  779:	    {
    #####:  780:	      drawCard(i, state);
call    0 never executed
        -:  781:	    }
        -:  782:	}
        -:  783:			
        -:  784:      //put played card in played card pile
    #####:  785:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  786:			
    #####:  787:      return 0;
        -:  788:			
        -:  789:    case feast:
        -:  790:      //gain card with cost up to 5
        -:  791:      //Backup hand
    #####:  792:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  793:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  794:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  795:      }
        -:  796:      //Backup hand
        -:  797:
        -:  798:      //Update Coins for Buy
    #####:  799:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  800:      x = 1;//Condition to loop on
    #####:  801:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  802:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:	  if (DEBUG)
        -:  804:	    printf("None of that card left, sorry!\n");
        -:  805:
        -:  806:	  if (DEBUG){
        -:  807:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  808:	  }
        -:  809:	}
    #####:  810:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  811:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  812:
        -:  813:	  if (DEBUG){
        -:  814:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  815:	  }
        -:  816:	}
        -:  817:	else{
        -:  818:
        -:  819:	  if (DEBUG){
        -:  820:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  821:	  }
        -:  822:
    #####:  823:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  824:	  x = 0;//No more buying cards
        -:  825:
        -:  826:	  if (DEBUG){
        -:  827:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  828:	  }
        -:  829:
        -:  830:	}
        -:  831:      }     
        -:  832:
        -:  833:      //Reset Hand
    #####:  834:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  835:	state->hand[currentPlayer][i] = temphand[i];
    #####:  836:	temphand[i] = -1;
        -:  837:      }
        -:  838:      //Reset Hand
        -:  839:      			
    #####:  840:      return 0;
        -:  841:			
        -:  842:    case gardens:
    #####:  843:      return -1;
        -:  844:			
        -:  845:    case mine:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:		
    #####:  853:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:
    #####:  858:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  864:
        -:  865:      //discard card from hand
    #####:  866:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  867:
        -:  868:      //discard trashed card
    #####:  869:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  870:	{
    #####:  871:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  872:	    {
    #####:  873:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  874:	      break;
        -:  875:	    }
        -:  876:	}
        -:  877:			
    #####:  878:      return 0;
        -:  879:			
        -:  880:    case remodel:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:
    #####:  888:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  889:
        -:  890:      //discard card from hand
    #####:  891:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  892:
        -:  893:      //discard trashed card
    #####:  894:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  895:	{
    #####:  896:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  897:	    {
    #####:  898:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  899:	      break;
        -:  900:	    }
        -:  901:	}
        -:  902:
        -:  903:
    #####:  904:      return 0;
        -:  905:		
        -:  906:    case smithy:
    #####:  907: 	return dom_smithy(handPos, currentPlayer, state);
call    0 never executed
        -:  908:	
        -:  909:    case village:
    #####:  910:   	return dom_village(handPos, currentPlayer, state);
call    0 never executed
        -:  911:
        -:  912:    case baron:
    #####:  913:      state->numBuys++;//Increase buys by 1!
    #####:  914:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  915:	int p = 0;//Iterator for hand!
    #####:  916:	int card_not_discarded = 1;//Flag for discard set!
    #####:  917:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  918:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  919:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  920:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  921:	    state->discardCount[currentPlayer]++;
    #####:  922:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  923:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  924:	    }
    #####:  925:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  926:	    state->handCount[currentPlayer]--;
    #####:  927:	    card_not_discarded = 0;//Exit the loop
        -:  928:	  }
    #####:  929:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  930:	    if(DEBUG) {
        -:  931:	      printf("No estate cards in your hand, invalid choice\n");
        -:  932:	      printf("Must gain an estate if there are any\n");
        -:  933:	    }
    #####:  934:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  936:	      state->supplyCount[estate]--;//Decrement estates
    #####:  937:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:		isGameOver(state);
call    0 never executed
        -:  939:	      }
        -:  940:	    }
    #####:  941:	    card_not_discarded = 0;//Exit the loop
        -:  942:	  }
        -:  943:			    
        -:  944:	  else{
    #####:  945:	    p++;//Next card
        -:  946:	  }
        -:  947:	}
        -:  948:      }
        -:  949:			    
        -:  950:      else{
    #####:  951:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  953:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  954:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:	    isGameOver(state);
call    0 never executed
        -:  956:	  }
        -:  957:	}
        -:  958:      }
        -:  959:	    
        -:  960:      
    #####:  961:      return 0;
        -:  962:		
        -:  963:    case great_hall:
        -:  964:      //+1 Card
    #####:  965:      drawCard(currentPlayer, state);
call    0 never executed
        -:  966:			
        -:  967:      //+1 Actions
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  972:      return 0;
        -:  973:		
        -:  974:    case minion:
        -:  975:      //+1 action
    #####:  976:      state->numActions++;
        -:  977:			
        -:  978:      //discard card from hand
    #####:  979:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  980:			
    #####:  981:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  982:	{
    #####:  983:	  state->coins = state->coins + 2;
        -:  984:	}
        -:  985:			
    #####:  986:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  987:	{
        -:  988:	  //discard hand
    #####:  989:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  990:	    {
    #####:  991:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  992:	    }
        -:  993:				
        -:  994:	  //draw 4
    #####:  995:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	    {
    #####:  997:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  998:	    }
        -:  999:				
        -: 1000:	  //other players discard hand and redraw if hand size > 4
    #####: 1001:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1002:	    {
    #####: 1003:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1004:		{
    #####: 1005:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1006:		    {
        -: 1007:		      //discard hand
    #####: 1008:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1009:			{
    #####: 1010:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1011:			}
        -: 1012:							
        -: 1013:		      //draw 4
    #####: 1014:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1015:			{
    #####: 1016:			  drawCard(i, state);
call    0 never executed
        -: 1017:			}
        -: 1018:		    }
        -: 1019:		}
        -: 1020:	    }
        -: 1021:				
        -: 1022:	}
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case steward:
    #####: 1026:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
        -: 1028:	  //+2 cards
    #####: 1029:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1030:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1031:	}
    #####: 1032:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1033:	{
        -: 1034:	  //+2 coins
    #####: 1035:	  state->coins = state->coins + 2;
        -: 1036:	}
        -: 1037:      else
        -: 1038:	{
        -: 1039:	  //trash 2 cards in hand
    #####: 1040:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1041:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1042:	}
        -: 1043:			
        -: 1044:      //discard card from hand
    #####: 1045:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1046:      return 0;
        -: 1047:		
        -: 1048:    case tribute:
    #####: 1049:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1050:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1051:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1052:	  state->deckCount[nextPlayer]--;
        -: 1053:	}
    #####: 1054:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1056:	  state->discardCount[nextPlayer]--;
        -: 1057:	}
        -: 1058:	else{
        -: 1059:	  //No Card to Reveal
        -: 1060:	  if (DEBUG){
        -: 1061:	    printf("No cards to reveal\n");
        -: 1062:	  }
        -: 1063:	}
        -: 1064:      }
        -: 1065:	    
        -: 1066:      else{
    #####: 1067:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1068:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1069:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1070:	    state->deckCount[nextPlayer]++;
    #####: 1071:	    state->discard[nextPlayer][i] = -1;
    #####: 1072:	    state->discardCount[nextPlayer]--;
        -: 1073:	  }
        -: 1074:			    
    #####: 1075:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1076:	} 
    #####: 1077:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1078:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1079:	state->deckCount[nextPlayer]--;
    #####: 1080:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1081:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1082:	state->deckCount[nextPlayer]--;
        -: 1083:      }    
        -: 1084:		       
    #####: 1085:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1086:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1087:	state->playedCardCount++;
    #####: 1088:	tributeRevealedCards[1] = -1;
        -: 1089:      }
        -: 1090:
    #####: 1091:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1092:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1093:	  state->coins += 2;
        -: 1094:	}
        -: 1095:		    
    #####: 1096:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1097:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1098:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1099:	}
        -: 1100:	else{//Action Card
    #####: 1101:	  state->numActions = state->numActions + 2;
        -: 1102:	}
        -: 1103:      }
        -: 1104:	    
    #####: 1105:      return 0;
        -: 1106:		
        -: 1107:    case ambassador:
    #####: 1108:      j = 0;		//used to check if player has enough cards to discard
        -: 1109:
    #####: 1110:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:	{
    #####: 1112:	  return -1;				
        -: 1113:	}
        -: 1114:
    #####: 1115:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1116:	{
    #####: 1117:	  return -1;
        -: 1118:	}
        -: 1119:
    #####: 1120:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1121:	{
    #####: 1122:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1123:	    {
    #####: 1124:	      j++;
        -: 1125:	    }
        -: 1126:	}
    #####: 1127:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1128:	{
    #####: 1129:	  return -1;				
        -: 1130:	}
        -: 1131:
        -: 1132:      if (DEBUG) 
        -: 1133:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1134:
        -: 1135:      //increase supply count for choosen card by amount being discarded
    #####: 1136:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1137:			
        -: 1138:      //each other player gains a copy of revealed card
    #####: 1139:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1140:	{
    #####: 1141:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1142:	    {
    #####: 1143:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1144:	    }
        -: 1145:	}
        -: 1146:
        -: 1147:      //discard played card from hand
    #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1149:
        -: 1150:      //trash copies of cards returned to supply
    #####: 1151:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1152:	{
    #####: 1153:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:	    {
    #####: 1155:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1156:		{
    #####: 1157:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1158:		  break;
        -: 1159:		}
        -: 1160:	    }
        -: 1161:	}			
        -: 1162:
    #####: 1163:      return 0;
        -: 1164:		
        -: 1165:    case cutpurse:
        -: 1166:
    #####: 1167:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1168:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1169:	{
    #####: 1170:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1171:	    {
    #####: 1172:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1173:		{
    #####: 1174:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1175:		    {
    #####: 1176:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1177:		      break;
        -: 1178:		    }
    #####: 1179:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1180:		    {
    #####: 1181:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1182:			{
        -: 1183:			  if (DEBUG)
        -: 1184:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1185:			}	
    #####: 1186:		      break;
        -: 1187:		    }		
        -: 1188:		}
        -: 1189:					
        -: 1190:	    }
        -: 1191:				
        -: 1192:	}				
        -: 1193:
        -: 1194:      //discard played card from hand
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1196:
    #####: 1197:      return 0;
        -: 1198:
        -: 1199:		
        -: 1200:    case embargo: 
    #####: 1201:      return dom_embargo(choice1, handPos, currentPlayer, state);
call    0 never executed
        -: 1202:	
        -: 1203:    case outpost:
    #####: 1204:      return dom_outpost(handPos, currentPlayer, state);
call    0 never executed
        -: 1205:	
        -: 1206:    case salvager:
        -: 1207:      //+1 buy
    #####: 1208:      state->numBuys++;
        -: 1209:			
    #####: 1210:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1211:	{
        -: 1212:	  //gain coins equal to trashed card
    #####: 1213:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1214:	  //trash card
    #####: 1215:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1216:	}
        -: 1217:			
        -: 1218:      //discard card
    #####: 1219:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case sea_hag:
    #####: 1223:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1224:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1225:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1226:	  state->discardCount[i]++;
    #####: 1227:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1228:	}
        -: 1229:      }
    #####: 1230:      return 0;
        -: 1231:		
        -: 1232:    case treasure_map:
        -: 1233:      //search hand for another treasure_map
    #####: 1234:      index = -1;
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1238:	    {
    #####: 1239:	      index = i;
    #####: 1240:	      break;
        -: 1241:	    }
        -: 1242:	}
    #####: 1243:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1244:	{
        -: 1245:	  //trash both treasure cards
    #####: 1246:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1247:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1248:
        -: 1249:	  //gain 4 Gold cards
    #####: 1250:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1251:	    {
    #####: 1252:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1253:	    }
        -: 1254:				
        -: 1255:	  //return success
    #####: 1256:	  return 1;
        -: 1257:	}
        -: 1258:			
        -: 1259:      //no second treasure_map found in hand
    #####: 1260:      return -1;
        -: 1261:    }
        -: 1262:	
    #####: 1263:  return -1;
        -: 1264:}
        -: 1265:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1266:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1267:{
        -: 1268:	
        -: 1269:  //if card is not trashed, added to Played pile 
    #####: 1270:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //add card to played pile
    #####: 1273:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1274:      state->playedCardCount++;
        -: 1275:    }
        -: 1276:	
        -: 1277:  //set played card to -1
    #####: 1278:  state->hand[currentPlayer][handPos] = -1;
        -: 1279:	
        -: 1280:  //remove card from player's hand
    #####: 1281:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1282:    {
        -: 1283:      //reduce number of cards in hand
    #####: 1284:      state->handCount[currentPlayer]--;
        -: 1285:    }
    #####: 1286:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1287:    {
        -: 1288:      //reduce number of cards in hand
    #####: 1289:      state->handCount[currentPlayer]--;
        -: 1290:    }
        -: 1291:  else 	
        -: 1292:    {
        -: 1293:      //replace discarded card with last card in hand
    #####: 1294:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1295:      //set last card to -1
    #####: 1296:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1297:      //reduce number of cards in hand
    #####: 1298:      state->handCount[currentPlayer]--;
        -: 1299:    }
        -: 1300:	
    #####: 1301:  return 0;
        -: 1302:}
        -: 1303:
function gainCard called 6 returned 100% blocks executed 70%
        6: 1304:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1305:{
        -: 1306:  //Note: supplyPos is enum of choosen card
        -: 1307:	
        -: 1308:  //check if supply pile is empty (0) or card is not used in game (-1)
        6: 1309:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 6
branch  1 taken 0 (fallthrough)
branch  2 taken 6
        -: 1310:    {
    #####: 1311:      return -1;
        -: 1312:    }
        -: 1313:	
        -: 1314:  //added card for [whoseTurn] current player:
        -: 1315:  // toFlag = 0 : add to discard
        -: 1316:  // toFlag = 1 : add to deck
        -: 1317:  // toFlag = 2 : add to hand
        -: 1318:
        6: 1319:  if (toFlag == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1320:    {
    #####: 1321:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1322:      state->deckCount[player]++;
        -: 1323:    }
        6: 1324:  else if (toFlag == 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1325:    {
    #####: 1326:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1327:      state->handCount[player]++;
        -: 1328:    }
        -: 1329:  else
        -: 1330:    {
        6: 1331:      state->discard[player][ state->discardCount[player] ] = supplyPos;
        6: 1332:      state->discardCount[player]++;
        -: 1333:    }
        -: 1334:	
        -: 1335:  //decrease number in supply pile
        6: 1336:  state->supplyCount[supplyPos]--;
        -: 1337:	 
        6: 1338:  return 0;
        -: 1339:}
        -: 1340:
function updateCoins called 1018 returned 100% blocks executed 82%
     1018: 1341:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1342:{
        -: 1343:  int i;
        -: 1344:	
        -: 1345:  //reset coin count
     1018: 1346:  state->coins = 0;
        -: 1347:
        -: 1348:  //add coins for each Treasure card in player's hand
     6108: 1349:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 5090
branch  1 taken 1018 (fallthrough)
        -: 1350:    {
     5090: 1351:      if (state->hand[player][i] == copper)
branch  0 taken 3964 (fallthrough)
branch  1 taken 1126
        -: 1352:	{
     3964: 1353:	  state->coins += 1;
        -: 1354:	}
     1126: 1355:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 1126
        -: 1356:	{
    #####: 1357:	  state->coins += 2;
        -: 1358:	}
     1126: 1359:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 1126
        -: 1360:	{
    #####: 1361:	  state->coins += 3;
        -: 1362:	}	
        -: 1363:    }	
        -: 1364:
        -: 1365:  //add bonus
     1018: 1366:  state->coins += bonus;
        -: 1367:
     1018: 1368:  return 0;
        -: 1369:}
        -: 1370:
        -: 1371:
        -: 1372://end of dominion.c
        -: 1373:
